I"+5<blockquote>
  <p><a href="https://programmers.co.kr/learn/courses/57">프로그래머스 - 어서와! 자료구조와 알고리즘은 처음이지?</a>를 공부하며 정리한 내용입니다.</p>
</blockquote>

<h1 id="8강-연결-리스트-노드-삭제하기">8강. 연결 리스트 노드 삭제하기</h1>

<h1 id="연습문제">연습문제</h1>

<blockquote>
  <p>제 8 강에서 소개된 추상적 자료구조 LinkedList 클래스의 메서드로서 popAt() 메서드를 강의 내용에 소개된 요구조건을 만족시키도록 구현하세요.
초기 코드로 들어 있는 것은 solution() 함수를 포함하여 다른 부분은 수정하지 말고, def popAt(self, pos): 의 메서드 몸체만 구현하세요.
만약, 인자로 주어진 pos 가 올바른 범위의 값을 가지지 않는 경우에는 IndexError exception 을 발생시키도록 합니다. 이렇게 하기 위한 코드는 raise IndexError 입니다.
*** 2020년 3월 23일, 학습자의 질문에 답하면서 보니 특정한 경우의 정확성을 올바르게 검증하지 못하는 경우가 발견되어 테스트 케이스 4 번을 추가했습니다.</p>
</blockquote>

<h2 id="나의-풀이">나의 풀이</h2>

<p>케이스를 구분해서 접근해보았다.</p>

<ol>
  <li>연결 리스트 길이가 1인 경우
    <ul>
      <li>원소가 1개 존재하므로 <code class="language-plaintext highlighter-rouge">head = tail</code>이 된다.</li>
      <li>따라서 <code class="language-plaintext highlighter-rouge">self.head.data</code>를 반환한다.</li>
      <li>그리고 <code class="language-plaintext highlighter-rouge">next</code>는 처음부터 존재하지 않았으므로, <code class="language-plaintext highlighter-rouge">head</code>와 <code class="language-plaintext highlighter-rouge">tail</code>만 <code class="language-plaintext highlighter-rouge">None</code>으로 바꿔준다.</li>
    </ul>
  </li>
  <li>연결 리스트 길이가 2 이상인 경우
    <ol>
      <li>맨 앞의 원소인 경우
        <ul>
          <li><code class="language-plaintext highlighter-rouge">curr</code>는 <code class="language-plaintext highlighter-rouge">self.head</code>이다.</li>
          <li>따라서 <code class="language-plaintext highlighter-rouge">self.head.data</code>를 반환한다.</li>
          <li><code class="language-plaintext highlighter-rouge">self.head</code>는 그 다음 원소인 <code class="language-plaintext highlighter-rouge">curr.next</code>가 된다.</li>
          <li><code class="language-plaintext highlighter-rouge">curr.next</code>는 <code class="language-plaintext highlighter-rouge">None</code>가 된다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">2 ~ n</code>번째 원소인 경우
        <ul>
          <li>함수를 최소한으로 사용하기 위해서 n번째가 아닌 n-1번째 원소를 구한다.</li>
          <li><code class="language-plaintext highlighter-rouge">prev = self.getAt(pos-1)</code>
            <ol>
              <li>마지막 원소인 경우</li>
            </ol>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">curr = prev.next</code></li>
              <li><code class="language-plaintext highlighter-rouge">self.tail</code>은 n-1번째 원소인 <code class="language-plaintext highlighter-rouge">prev</code>가 되어야 한다. <code class="language-plaintext highlighter-rouge">self.tail = prev</code></li>
              <li>그리고 <code class="language-plaintext highlighter-rouge">prev</code>가 마지막 원소가 되므로 <code class="language-plaintext highlighter-rouge">prev.next = None</code>이다.
     2.  <code class="language-plaintext highlighter-rouge">2 ~ n-1</code> 번째 원소인 경우</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">curr = self.getAt(pos)</code></li>
          <li>이전 원소의 <code class="language-plaintext highlighter-rouge">next</code>와 현재 원소의 <code class="language-plaintext highlighter-rouge">next</code>만 변경해주면 된다.</li>
          <li><code class="language-plaintext highlighter-rouge">prev.next = curr.next</code></li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<p>다소 복잡하게 접근했지만, 결국 풀긴 풀었다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> --><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">popAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
            
    <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 연결 리스트 길이가 1인 경우
</span>        <span class="n">answer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 연결 리스트 길이가 2 이상인 경우
</span>        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 맨 앞의 노드인 경우
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">data</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># 2번째 ~ 마지막 노드
</span>            <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getAt</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">data</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span> <span class="c1"># 마지막 노드인 경우
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">prev</span>
                <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># 2번째 ~ n-1번째 노드인 경우
</span>                <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">answer</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="다른-사람의-풀이">다른 사람의 풀이</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">popAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">getAt</span><span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">nodeCount</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">data</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="1-첫-번째-원소인-경우">1. 첫 번째 원소인 경우</h3>

<ul>
  <li>반환하는 값은 <code class="language-plaintext highlighter-rouge">curr = self.head</code>의 <code class="language-plaintext highlighter-rouge">data</code>이다.</li>
  <li><code class="language-plaintext highlighter-rouge">self.head</code>만 다음 원소인 <code class="language-plaintext highlighter-rouge">curr.next</code>로 지정한다.</li>
  <li>만약 길이가 1인 연결 리스트인 경우에 남은 노드를 삭제하면 <code class="language-plaintext highlighter-rouge">head</code>와 <code class="language-plaintext highlighter-rouge">tail</code>이 같아진다.</li>
</ul>

<h3 id="2-두-번째-이후-원소인-경우">2. 두 번째 이후 원소인 경우</h3>

<ul>
  <li>맨 마지막 원소를 <code class="language-plaintext highlighter-rouge">pos</code>로 찾으면 이전 원소(<code class="language-plaintext highlighter-rouge">pos-1</code>)에 대한 정보를 얻을 수 없다.</li>
  <li>따라서 n-1번째를 구하기 위해 <code class="language-plaintext highlighter-rouge">prev = getAt(pos-1)</code>로 <code class="language-plaintext highlighter-rouge">n-1</code>번째 원소를 구한다.</li>
  <li>그러면 마지막 원소도 자연스럽게 <code class="language-plaintext highlighter-rouge">curr = prev.next</code>로 구할 수 있다.</li>
  <li>만약 마지막 원소일 경우에는 <code class="language-plaintext highlighter-rouge">tail</code>은 기존에 n-1번째인 <code class="language-plaintext highlighter-rouge">prev</code>가 된다.</li>
</ul>
:ET