<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="[42Seoul] pipex (3) 구현 과정" /><meta name="author" content="Joon Hyeok Han" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="회고" /><meta property="og:description" content="회고" /><link rel="canonical" href="https://han-joon-hyeok.github.io/posts/pipex-3-solution/" /><meta property="og:url" content="https://han-joon-hyeok.github.io/posts/pipex-3-solution/" /><meta property="og:site_name" content="Dev Joon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-30T08:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[42Seoul] pipex (3) 구현 과정" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Joon Hyeok Han" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Joon Hyeok Han"},"dateModified":"2023-11-02T00:06:02+09:00","datePublished":"2023-01-30T08:00:00+09:00","description":"회고","headline":"[42Seoul] pipex (3) 구현 과정","mainEntityOfPage":{"@type":"WebPage","@id":"https://han-joon-hyeok.github.io/posts/pipex-3-solution/"},"url":"https://han-joon-hyeok.github.io/posts/pipex-3-solution/"}</script><title>[42Seoul] pipex (3) 구현 과정 | Dev Joon</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-SKST7KNWSJ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SKST7KNWSJ'); }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}}); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dev Joon</a></div><div class="site-subtitle font-italic">성장하는 개발자, 한준혁입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Han-Joon-Hyeok" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['joonhyeok.han','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[42Seoul] pipex (3) 구현 과정</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[42Seoul] pipex (3) 구현 과정</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 30, 2023, 8:00 AM +0900" > Jan 30, 2023 <i class="unloaded">2023-01-30T08:00:00+09:00</i> </span> by <span class="author"> Joon Hyeok Han </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 2, 2023, 12:06 AM +0900" > Nov 2, 2023 <i class="unloaded">2023-11-02T00:06:02+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6126 words">34 min</span></div></div><div class="post-content"><h1 id="회고">회고</h1><h2 id="어서와-멀티-프로세스는-처음이지">어서와, 멀티 프로세스는 처음이지?</h2><p>그동안 수행했던 과제들은 모두 하나의 프로세스를 사용했다.</p><p>이번 과제는 처음으로 멀티 프로세스를 구현하고, 프로세스 간 통신(IPC)을 위해 파이프를 사용했다.</p><p>처음 보는 개념이 많다보니 이해하는데 시간이 꽤 걸렸다.</p><p>게다가 멀티 프로세스는 디버깅을 하는 것이 어려워서 디버깅에도 시간을 많이 썼다.</p><p>익숙하지 않은 개념을 이해하기 위해 그림을 그려서 이해하고자 노력했다.</p><p>그리고 다른 동료들에게 물어가며 내가 이해하고 있는 것이 맞는지 계속 확인했다.</p><p>그 결과로 효율적인 코드를 작성한 것은 아니지만, 멀티 프로세스가 어떻게 돌아가는지 이해할 수 있었다.</p><p>멀티 프로세스의 핵심은 병렬성이라 생각한다.</p><p>혼자서 많은 일을 해야 하는 것을 여럿이 나누어 효율적으로 처리하는 것이다.</p><p>그래서 부모 프로세스와 자식 프로세스가 수행해야 하는 작업은 정해져 있고, 자식 프로세스는 실행 결과를 부모 프로세스에게 전달해주어야 한다.</p><p>보너스에서는 히어독과 멀티 파이프를 다루는데, 이후 미니쉘 과제에서 어차피 구현할 거면 미리 구현하자는 생각으로 보너스를 했다.</p><p>사실 미니쉘에서 구현하는 것과는 조금 차이가 있지만, 미리 이 과제에서 공부한 덕분에 미니쉘에서는 해당 부분에 대해 큰 시간을 들이지 않을 수 있었다.</p><p>프로세스에 대한 이해가 있어야 미니쉘 뿐만 아니라 exam04 도 수월하게 통과할 수 있으니, 충분한 시간을 들여서 이 과제를 수행하는 것을 추천한다.</p><h1 id="mandatory-구현">Mandatory 구현</h1><h2 id="구조">구조</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/1.png" alt="1.png" /></p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>./pipex infile cmd1 cmd2 outfile
</pre></table></code></div></div><p>위의 명령어를 실행한다고 했을 때, <code class="language-plaintext highlighter-rouge">cmd1</code> 와 <code class="language-plaintext highlighter-rouge">cmd2</code> 모두 자식 프로세스를 생성해서 실행한다.</p><p>마지막으로 <code class="language-plaintext highlighter-rouge">cmd2</code> 를 실행하는 자식 프로세스는 종료 상태를 부모 프로세스로 반환한다.</p><h2 id="학습-내용">학습 내용</h2><p><code class="language-plaintext highlighter-rouge">pipex</code> 과제를 통해 멀티 프로세스와 파이프 대해 배울 수 있다.</p><h3 id="프로세스">프로세스</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/2.png" alt="2.png" /></p><p>출처: <a href="https://wookkingkim.tistory.com/m/entry/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C">[운영체제]멀티 프로세스 vs 멀티 스레드</a> [티스토리]</p><p>프로세스를 살펴보기 전에 <strong>프로그램</strong>이란 무엇인지 살펴보자. 사전적 의미의 프로그램은 <strong>업무를 어떻게 수행할 것인지 작성한 계획이나 순서</strong>를 의미한다. 즉, 어떤 작업을 하기 위해 해야할 일들을 순서대로 나열한 것이다. 비슷한 맥락에서 컴퓨터가 사용하는 프로그램의 의미는 <strong>어떤 작업을 하기 위한 명령어 목록과 이에 필요한 데이터를 묶어놓은 파일</strong>이다. 컴퓨터의 프로그램은 보조 기억장치(HDD 또는 SSD)에 저장되어있다.</p><p>프로세스란 프로그램이 메모리에 적재되어 실행되고 있는 인스턴스를 의미한다. 즉, 운영체제로부터 시스템 자원을 할당 받는 작업의 단위이다. 운영체제에는 한정된 자원으로 여러 프로세스를 효율적으로 사용하기 위해 다음 실행 시간에 실행할 수 있는 프로세스 중 하나를 선택하는 스케줄러(Scheduler)가 있다. 이때, 프로세스는 스케줄러의 선택을 받으면 실행된다.</p><p>프로세스는 각각 독립된 메모리 영역(코드, 데이터, 스택, 힙)과 주소 공간을 운영체제로부터 할당 받는다.</p><ul><li>코드(Code) : 프로세스가 실행할 코드와 매크로 상수가 기계어의 형태로 저장된 공간. 컴파일 타임에 결정되며, 중간에 코드를 바꿀 수 없도록 Read-Only 로 지정되어 있다.<li>데이터(Data) : 코드에서 선언한 전역 변수 또는 static 변수 등이 저장된 공간. 전역 변수나 static 변수의 값을 참조한 코드는 컴파일 이후 Data 영역의 주소값을 가리키도록 바뀐다. 실행을 거치며 값이 바뀔 수도 있기 때문에 Read-Write 로 지정되어 있다.<li>스택(Stack) : 프로세스의 메모리 공간을 관리하기 위한 영역. 함수 안에서 선언된 지역 변수, 매개변수, 리턴값, 돌아올 주소 등이 저장된다. 함수 호출 시 기록하고, 함수 호출이 끝나면 제거된다. 기록 및 제거는 후위선출(LIFO) 방식을 따른다.<li>힙(Heap) : 프로그래머가 필요할 때마다 사용하는 메모리 영역. 나머지 영역과는 달리 런타임(프로그램이 실제로 실행되는 시간)에 결정된다. <code class="language-plaintext highlighter-rouge">malloc</code> 이나 <code class="language-plaintext highlighter-rouge">calloc</code> 함수를 사용하면 할당 받는 공간이 힙 영역이다. 데이터 배열의 크기가 고정적이지 않을 때 힙 영역을 사용한다. 단, 사용하고 나서 반드시 할당받은 메모리는 해제 해야 한다. 그렇지 않으면 메모리 누수(Memory leak)가 발생한다.</ul><p>프로세스는 각각 독립된 영역이므로 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 그래서 다른 프로세스의 자원에 접근하고 싶다면 파이프, 시그널, 소켓, RPC(Remote Procedure Call)과 같은 프로세스 간 통신(IPC; Inter-Process Communication)을 사용해야 한다.</p><h3 id="멀티-프로세스">멀티 프로세스</h3><p>멀티 프로세스는 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하는 것을 의미한다.</p><p>멀티 프로세스는 다양하게 사용되고 있다.</p><ol><li>크롬 브라우저 페이지 탭 : 특정 페이지의 클라이언트 페이지 코드에서 오류가 발생했을 때, 다른 열려있는 페이지들이 종료되지 않도록 각 페이지는 별도의 프로세스에서 실행되고 있다.<li>쉘 명령어 실행 : 쉘에서 명령어를 실행하고 나서 오류가 발생하더라도 전체 쉘에 영향이 가지 않도록 자식 프로세스를 생성해서 명령어, 리다이렉션, 히어독 등을 실행한다.</ol><p>이처럼 멀티 프로세스의 가장 큰 장점은 안정성이 확보된다는 것이다. 여러 자식 프로세스 중 하나만 문제가 발생해도 다른 자식 프로세스에 영향이 확산되지 않는다.</p><p>자식 프로세스를 생성하면 부모 프로세스의 변수와</p><p>하지만 멀티 프로세스의 단점은 다음과 같다.</p><p>IPC 파이프</p><h2 id="예외처리">예외처리</h2><h3 id="1-인자의-개수가-일치하지-않을-때">1. 인자의 개수가 일치하지 않을 때</h3><p>Mandatory 기준으로 pipex 프로그램은 아래와 같이 인자가 총 5개(실행 파일명 포함)가 전달되어야 작동한다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>./pipex infile cmd1 cmd2 outfile
</pre></table></code></div></div><p>만약, 인자의 개수가 5개가 아니라면 작동하지 않아야 한다.</p><p>예를 들어, 아래와 같이 인자의 개수가 4개인 경우에 해당한다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>./pipex infile <span class="s2">"grep hell"</span> <span class="s2">"ls -l"</span>
</pre></table></code></div></div><p>실행 결과는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>❌Error: The number of arguments should be 5.
</pre></table></code></div></div><h3 id="2-환경변수-path가-unset-된-경우">2. 환경변수 PATH가 unset 된 경우</h3><p>쉘의 명령어를 실행하기 위해서는 환경변수 중에서 <code class="language-plaintext highlighter-rouge">PATH</code> 라는 변수가 있어야 한다.<code class="language-plaintext highlighter-rouge">PATH</code> 변수에는 프로그램이나 라이브러리를 설치하여 실행할 수 있는 경로가 저장되어 있기 때문이다.</p><p>만약, <code class="language-plaintext highlighter-rouge">PATH</code> 변수가 빈 값이거나 존재하지 않는다면 명령어를 정상적으로 실행할 수 없다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c"># PATH 환경변수 해제</span>
<span class="nv">$ </span><span class="nb">unset </span>PATH

<span class="c"># ls 실행</span>
<span class="nv">$ </span><span class="nb">ls
</span>zsh: <span class="nb">ls</span>: No such file or directory

<span class="c"># exit status 확인</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
127
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">$?</code> 는 마지막으로 실행한 명령어의 exit code 를 저장하는데, <code class="language-plaintext highlighter-rouge">127</code> 은 <code class="language-plaintext highlighter-rouge">command not found</code> 에 해당한다.</p><p>쉘에서는 <code class="language-plaintext highlighter-rouge">unset PATH</code> 를 수행하고 아래와 같이 명령어를 수행했을 때,</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>&lt; infile <span class="nb">grep </span>hello | <span class="nb">wc</span> <span class="nt">-l</span> <span class="o">&gt;</span> outfile
</pre></table></code></div></div><p>실행 결과는 다음과 같다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>zsh: command not found: grep
zsh: command not found: wc
</pre></table></code></div></div><p>그리고 <code class="language-plaintext highlighter-rouge">outfile</code> 은 빈 파일로 생성된다.</p><p>따라서 pipex 프로그램도 환경변수 <code class="language-plaintext highlighter-rouge">PATH</code> 를 <code class="language-plaintext highlighter-rouge">unset</code> 하고 아래와 같이 실행하면,</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c"># PATH 환경변수 해제</span>
<span class="nv">$ </span><span class="nb">unset </span>PATH
<span class="c"># pipex 실행</span>
<span class="nv">$ </span>./pipex infile <span class="s2">"grep hell"</span> <span class="s2">"ls -l"</span> outfile
</pre></table></code></div></div><p>실행결과는 다음과 같도록 처리했다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>❌Error: command not found: grep
❌Error: command not found: ls
</pre></table></code></div></div><p>또한, exit code 도 127 를 반환하도록 처리했다.</p><h3 id="3-표준-입력으로-넘긴-infile-이-존재하지-않거나-읽기-권한이-없을-때">3. 표준 입력으로 넘긴 infile 이 존재하지 않거나, 읽기 권한이 없을 때</h3><p>리다이렉션 <code class="language-plaintext highlighter-rouge">&lt;</code> 을 사용할 때 <code class="language-plaintext highlighter-rouge">infile</code> 이 존재하지 않을 때, 실행 결과는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>&lt; infile <span class="nb">ls</span> <span class="nt">-l</span> | <span class="nb">wc</span> <span class="nt">-l</span> <span class="o">&gt;</span> outfile
zsh: no such file or directory: infile
</pre></table></code></div></div><p>그리고 <code class="language-plaintext highlighter-rouge">infile</code> 에 대해 읽기 권한이 존재하지 않을 때 실행 결과는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>&lt; infile <span class="nb">ls</span> <span class="nt">-l</span> | <span class="nb">wc</span> <span class="nt">-l</span> <span class="o">&gt;</span> outfile
zsh: permission denied: infile
</pre></table></code></div></div><p>위의 2가지 경우에 대해서 동일하게 출력하고 프로세스를 종료하도록 했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># 파일이 존재하지 않을 때</span>
<span class="nv">$ </span>./pipex infile <span class="s2">"grep hell"</span> <span class="s2">"ls -l"</span> outfile
❌Error: No such file or directory: infile

<span class="c"># 읽기 권한이 존재하지 않을 때</span>
<span class="nv">$ </span>./pipex infile <span class="s2">"grep hell"</span> <span class="s2">"ls -l"</span> outfile
❌Error: permission denied: infile
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">fork</code> 함수 다음에 실행하는 것과 pipe 를 닫은 후에 실행하는 것과 어떤 차이가 있는가?</p><h3 id="4-유효한-명령어가-아닐-때">4. 유효한 명령어가 아닐 때</h3><p><code class="language-plaintext highlighter-rouge">infile</code> 이 존재한다고 가정하고, 유효하지 않은 명령어에 대해서는 3가지로 나눌 수 있다.</p><ol><li><p>첫 번째 명령어가 존재하지 않을 때</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>&lt; infile NOT_VALID_CMD <span class="nt">-l</span> | <span class="nb">wc</span> <span class="nt">-l</span> <span class="o">&gt;</span> outfile
zsh: <span class="nb">command </span>not found: NOT_VALID_CMD
</pre></table></code></div></div><p>이 경우에는 exit code 가 0 이 반환된다.</p><li><p>두 번째 명령어가 존재하지 않을 때</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>&lt; infile <span class="nb">ls</span> <span class="nt">-l</span> | NOT_VALID_CMD <span class="nt">-l</span> <span class="o">&gt;</span> outfile
zsh: <span class="nb">command </span>not found: NOT_VALID_CMD
</pre></table></code></div></div><p>파이프는 가장 마지막에 실행한 명령어의 실행 결과에 따라 exit code 가 바뀌는데, 이 경우에는 127(<code class="language-plaintext highlighter-rouge">command not found</code>)을 반환한다.</p><li><p>첫 번째, 두 번째 명령어 모두 존재하지 않을때</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>&lt; infile NOT_VALID_CMD1 <span class="nt">-l</span> | NOT_VALID_CMD2 <span class="nt">-l</span> <span class="o">&gt;</span> outfile
zsh: <span class="nb">command </span>not found: NOT_VALID_CMD1
zsh: <span class="nb">command </span>not found: NOT_VALID_CMD2
</pre></table></code></div></div><p>이 경우도 마찬가지로 파이프의 마지막 명령어가 정상적으로 실행되지 않았으므로 exit code는 127을 반환한다.</p></ol><h3 id="5-infile-이-멈추지-않고-계속-들어오는-경우urandom">5. <code class="language-plaintext highlighter-rouge">infile</code> 이 멈추지 않고 계속 들어오는 경우(urandom)</h3><p><code class="language-plaintext highlighter-rouge">waitpid</code> 함수에서 <code class="language-plaintext highlighter-rouge">WNOHANG</code> 옵션을 사용하면 스트림을 끊을 수 있다.</p><h1 id="bonus-구현">Bonus 구현</h1><h2 id="1-멀티-파이프">1. 멀티 파이프</h2><ol><li><p><code class="language-plaintext highlighter-rouge">infile</code> 을 <code class="language-plaintext highlighter-rouge">open</code> 함수로 연다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/3.png" alt="3.png" /></p><li><p><code class="language-plaintext highlighter-rouge">dup2(infile, STDIN_FILENO)</code> 를 실행하여 표준 입력 파일 디스크립터(0번)가 <code class="language-plaintext highlighter-rouge">infile</code> 을 가리키도록 한다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/4.png" alt="4.png" /></p><li><p>자식 프로세스를 생성하기 전에 부모 프로세스에서 <code class="language-plaintext highlighter-rouge">pipe</code> 를 생성한다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/5.png" alt="5.png" /></p><li><p><code class="language-plaintext highlighter-rouge">fork</code> 를 실행하면 자식 프로세스는 아래와 같이 <code class="language-plaintext highlighter-rouge">fork</code> 를 실행하는 당시 부모 프로세스의 파일 디스크립터 상태를 유지하며 생성된다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/6.png" alt="6.png" /></p><li><p>부모 프로세스는 자식 프로세스가 실행한 결과를 파이프로 받기 위해 <code class="language-plaintext highlighter-rouge">dup2(pipe_fd[0], STDIN_FILENO)</code> 를 실행한다. 그리고 부모 프로세스는 write 를 수행하지 않기 때문에 <code class="language-plaintext highlighter-rouge">close(pipe_fd[1])</code> 을 하고, 0번 파일 디스크립터가 파이프의 <code class="language-plaintext highlighter-rouge">read end</code> 를 가리키고 있기 때문에 <code class="language-plaintext highlighter-rouge">close(pipe_fd[0])</code> 를 하여 사용하지 않는 파일 디스크립터를 닫아준다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 부모 프로세스</span>
<span class="n">close</span><span class="p">(</span><span class="n">pipe_fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">pipe_fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">STDIN_FILENO</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">pipe_fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WNOHANG</span><span class="p">);</span>
</pre></table></code></div></div><p>그림으로 표현하면 다음과 같다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/7.png" alt="7.png" /></p><li><p>자식 프로세스는 명령어를 실행시킨 결과를 파이프의 <code class="language-plaintext highlighter-rouge">write end</code> 에 입력해야 하기 때문에 read 작업은 수행하지 않는다. 따라서 <code class="language-plaintext highlighter-rouge">close(pipe_fd[0])</code> 을 하고, <code class="language-plaintext highlighter-rouge">dup2(pipe_fd[1], STDOUT_FILENO)</code> 을 하여 표준 출력을 파이프의 <code class="language-plaintext highlighter-rouge">write end</code> 로 연결한다. 그리고 사용하지 않는 <code class="language-plaintext highlighter-rouge">pipe_fd[0]</code> 은 마찬가지로 <code class="language-plaintext highlighter-rouge">close</code> 한다. 이 과정이 끝나면 명령어를 실행한다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 자식 프로세스</span>
<span class="n">close</span><span class="p">(</span><span class="n">pipe_fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">pipe_fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">pipe_fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">execute_cmd</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">pipex</span><span class="p">);</span>
</pre></table></code></div></div><p>그림으로 표현하면 다음과 같다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/8.png" alt="8.png" /></p><li><p>두 번째 명령어를 실행시킬 때는 첫 번째 명령어와 달리 표준 입력을 <code class="language-plaintext highlighter-rouge">infile</code> 이 아닌 첫 번째 명령어의 실행 결과가 담겨있는 <code class="language-plaintext highlighter-rouge">pipe_fd[0]</code> 에서 가져온다. 이때, 파이프는 자식 프로세스를 생성하기 전에 새롭게 생성한다. 이전에 부모 프로세스 실행했던 코드 그대로 작동시키면 아래와 같아진다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/9.png" alt="9.png" /></p><li><p>자식 프로세스도 이전에 수행했던 과정을 그대로 수행하면 아래의 그림과 같아진다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/10.png" alt="10.png" /></p><p>즉, 자식 프로세스는 표준 입력이 이전 파이프의 <code class="language-plaintext highlighter-rouge">read end</code> 와 연결된 상태로 두 번째 명령어를 실행하여 새롭게 만든 파이프의 <code class="language-plaintext highlighter-rouge">write end</code> 에 출력 결과를 입력한다. 명령어의 개수가 N개라면 이 과정을 N-1 번 수행한다. N-1 번 수행하는 이유는 마지막 명령어인 N번째 명령어는 <code class="language-plaintext highlighter-rouge">outfile</code> 에 기록해야 하기 때문이다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">child_process</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">envp</span><span class="p">);</span>
</pre></table></code></div></div><li><p>마지막 명령어를 실행할 때는 <code class="language-plaintext highlighter-rouge">dup2(outfile, STDOUT_FILENO)</code> 를 실행하여 표준 출력을 <code class="language-plaintext highlighter-rouge">outfile</code> 로 바꾸어주고, 표준 입력은 N-1 번째 명령어를 실행한 결과를 파이프의 <code class="language-plaintext highlighter-rouge">read_end</code> 에서 읽어오면 된다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/11.png" alt="11.png" /></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">dup2</span><span class="p">(</span><span class="n">pipex</span><span class="p">.</span><span class="n">outfile</span><span class="p">,</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>
<span class="n">execute_cmd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">envp</span><span class="p">);</span>
</pre></table></code></div></div></ol><h2 id="2-here_doc">2. here_doc</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-01-30-pipex-3-solution/12.png" alt="12.png" /></p><p><code class="language-plaintext highlighter-rouge">heredoc</code> 을 실행하면 사용자의 입력을 받는 자식 프로세스를 생성한다. 사용자의 입력을 파이프의 <code class="language-plaintext highlighter-rouge">write end</code> 로 보내고 종료한다.</p><p>그 다음 <code class="language-plaintext highlighter-rouge">cmd1</code> 을 실행하는 자식 프로세스를 생성한다. 파이프의 <code class="language-plaintext highlighter-rouge">read end</code> 에서 사용자의 입력을 읽어와서 <code class="language-plaintext highlighter-rouge">cmd1</code> 실행하고, 실행 결과는 다시 파이프의 <code class="language-plaintext highlighter-rouge">write end</code> 에 보낸다.</p><p>마지막으로 부모 프로세스에서 <code class="language-plaintext highlighter-rouge">cmd2</code> 를 실행하는데, 파이프의 <code class="language-plaintext highlighter-rouge">read end</code> 에서 <code class="language-plaintext highlighter-rouge">cmd1</code> 실행 결과를 받아와서 <code class="language-plaintext highlighter-rouge">cmd2</code> 실행 결과를 <code class="language-plaintext highlighter-rouge">outfile</code> 로 저장한다.</p><h3 id="예외처리-1-인자가-here_doc-이-아닌-경우">예외처리 1. 인자가 <code class="language-plaintext highlighter-rouge">here_doc</code> 이 아닌 경우</h3><p>heredoc 을 실행할 때는 아래와 같이 2번째 인자를 <code class="language-plaintext highlighter-rouge">here_doc</code> 으로 받는다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 정상적인 상황</span>
<span class="nv">$ </span>./pipex here_doc <span class="s2">"HELLO"</span> <span class="nb">cat</span> <span class="s2">"wc -l"</span> outfile
</pre></table></code></div></div><p>하지만, <code class="language-plaintext highlighter-rouge">ft_strncmp</code> 만을 사용해서 <code class="language-plaintext highlighter-rouge">here_doc</code> 문자열 8글자만 검사한다면, 뒤에 다른 문자가 붙었을 때 오류가 발생할 수 있다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># here_doc까지는 동일하지만 뒤에 tor이 붙은 상황</span>
<span class="nv">$ </span>./pipex here_doctor <span class="s2">"HELLO"</span> <span class="nb">cat</span> <span class="s2">"wc -l"</span> outfile
</pre></table></code></div></div><p>따라서 <code class="language-plaintext highlighter-rouge">ft_strncmp</code> 으로 <code class="language-plaintext highlighter-rouge">here_doc</code> 까지 검사를 먼저 하고, <code class="language-plaintext highlighter-rouge">ft_strlen</code> 으로 문자열의 길이가 8이 아니라면 프로그램을 종료하도록 했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>./pipex here_doctor <span class="s2">"HELLO"</span> <span class="nb">cat</span> <span class="s2">"wc -l"</span> outfile
❌ Usage: <span class="o">[</span>./pipex here_doc LIMITER cmd cmd1 file]
</pre></table></code></div></div><p>반면, 아래처럼 <code class="language-plaintext highlighter-rouge">here_doc</code> 보다 길이가 작은 문자열이 들어오면 heredoc 이 아닌 <code class="language-plaintext highlighter-rouge">infile</code> 로 인식하기 때문에 <code class="language-plaintext highlighter-rouge">No such file or directory</code> 를 출력하도록 했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># here_do까지는 동일, 하지만 heredoc으로 실행되면 안됨.</span>
<span class="nv">$ </span>./pipex here_do <span class="s2">"HELLO"</span> <span class="nb">cat</span> <span class="s2">"wc -l"</span> outfile
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>./pipex here_do <span class="s2">"HELLO"</span> <span class="nb">cat</span> <span class="s2">"wc -l"</span> outfile
❌Error: No such file or directory
</pre></table></code></div></div><h3 id="예외처리-2-cmd1-이-유효한-명령어가-아닐-때">예외처리 2. <code class="language-plaintext highlighter-rouge">cmd1</code> 이 유효한 명령어가 아닐 때</h3><p>유효한 명령어가 아닌 경우는 명령어가 빈 문자열이거나, 실행할 수 없는 명령어인 경우이다.</p><p>우선 명령어가 빈 문자열인 경우이다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># cmd1 이 빈 문자열인 경우</span>
<span class="s2">""</span> <span class="o">&lt;&lt;</span> <span class="sh">"</span><span class="no">HELLO</span><span class="sh">" | ls &gt;&gt; outfile
</span></pre></table></code></div></div><p>실행 결과 및 exit code 는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 터미널 출력 결과</span>
bash: : <span class="nb">command </span>not found
<span class="c"># exit code 확인</span>
<span class="nb">echo</span> <span class="nv">$?</span>
0
</pre></table></code></div></div><p>다음으로 실행할 수 없는 명령어인 경우이다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c"># cmd1 이 실행할 수 없는 명령어인 경우</span>
<span class="c"># (command not found)</span>
meow <span class="o">&lt;&lt;</span> <span class="sh">"</span><span class="no">HELLO</span><span class="sh">" | ls &gt;&gt; outfile
</span></pre></table></code></div></div><p>실행 결과 및 exit code 는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 터미널 출력 결과</span>
bash: meow: <span class="nb">command </span>not found
<span class="c"># exit code 확인</span>
<span class="nb">echo</span> <span class="nv">$?</span>
0
</pre></table></code></div></div><p>두 경우 모두 터미널에는 <code class="language-plaintext highlighter-rouge">cmd1: command not found</code> 가 출력되고, <code class="language-plaintext highlighter-rouge">cmd2</code> 가 유효한 명령어(<code class="language-plaintext highlighter-rouge">ls</code>)이기 때문에 exit code 는 <code class="language-plaintext highlighter-rouge">0</code> 이 반환되었다.</p><p>따라서 위의 두 경우에 대해서 다음과 같이 처리하였고, exit code 는 두 번째 명령어의 실행 결과인 <code class="language-plaintext highlighter-rouge">0</code> 이 반환되도록 했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c"># cmd1 이 빈 명령어인 경우</span>
./pipex here_doc <span class="s2">"HELLO"</span> <span class="s2">""</span> <span class="s2">"ls"</span> outfile
heredoc&gt; HELLO
❌Error: <span class="nb">command </span>not found:

<span class="c"># cmd1 이 실행할 수 없는 명령어인 경우</span>
./pipex here_doc <span class="s2">"HELLO"</span> <span class="s2">"meow"</span> <span class="s2">"ls"</span> outfile
heredoc&gt; HELLO
❌Error: <span class="nb">command </span>not found: meow
</pre></table></code></div></div><h3 id="예외처리-3-cmd2-가-유효한-명령어가-아닐-때">예외처리 3. <code class="language-plaintext highlighter-rouge">cmd2</code> 가 유효한 명령어가 아닐 때</h3><p><code class="language-plaintext highlighter-rouge">cmd2</code> 가 유효하지 않은 경우는 마찬가지로 빈 문자열이 들어오거나 실행할 수 없는 명령어인 경우이다.</p><p>우선 빈 명령어가 들어오는 경우이다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># cmd2 가 명령어가 빈 문자열인 경우</span>
<span class="nb">ls</span> <span class="o">&lt;&lt;</span> <span class="sh">"</span><span class="no">HELLO</span><span class="sh">" | "" &gt;&gt; outfile
</span></pre></table></code></div></div><p>실행 결과는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="nb">ls</span> <span class="o">&lt;&lt;</span> <span class="sh">"</span><span class="no">HELLO</span><span class="sh">" | meow &gt;&gt; outfile
&gt; HELLO
bash: : command not found
bash-3.2</span><span class="nv">$ </span><span class="sh">echo </span><span class="nv">$?</span><span class="sh">
127
</span></pre></table></code></div></div><p>이때, <code class="language-plaintext highlighter-rouge">outfile</code> 은 빈 파일로 생성된다.</p><p>다음은 실행할 수 없는 명령어인 경우이다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># cmd2 가 실행할 수 없는 명령어인 경우</span>
<span class="nb">ls</span> <span class="o">&lt;&lt;</span> <span class="sh">"</span><span class="no">HELLO</span><span class="sh">" | meow &gt;&gt; outfile
</span></pre></table></code></div></div><p>실행 결과는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="nb">ls</span> <span class="o">&lt;&lt;</span> <span class="sh">"</span><span class="no">HELLO</span><span class="sh">" | meow &gt;&gt; outfile
&gt; HELLO
bash: meow: command not found
bash-3.2</span><span class="nv">$ </span><span class="sh">echo </span><span class="nv">$?</span><span class="sh">
127
</span></pre></table></code></div></div><p>마찬가지로 <code class="language-plaintext highlighter-rouge">outfile</code> 은 빈 파일로 생성된다.</p><p>위의 두 경우에 대해 다음과 같이 처리했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c"># cmd2 가 빈 문자열인 경우</span>
bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">"HELLO"</span> <span class="s2">"ls"</span> <span class="s2">""</span> outfile
heredoc&gt; HELLO
❌Error: <span class="nb">command </span>not found:
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
127

<span class="c"># cmd2 가 실행할 수 없는 명령어인 경우</span>
bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">"HELLO"</span> <span class="s2">"ls"</span> <span class="s2">"meow"</span> outfile
heredoc&gt; HELLO
❌Error: <span class="nb">command </span>not found: meow
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
127
</pre></table></code></div></div><h3 id="예외처리-4-outfile-이-존재하지-않는-경로에-있을-때">예외처리 4. <code class="language-plaintext highlighter-rouge">outfile</code> 이 존재하지 않는 경로에 있을 때</h3><p><code class="language-plaintext highlighter-rouge">No such file or directory</code> 메세지를 출력하며, exit code 는 <code class="language-plaintext highlighter-rouge">1</code> 이 반환된다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="nb">ls</span> &lt;&lt; <span class="s2">""</span> | <span class="nb">ls</span> <span class="o">&gt;&gt;</span> not_existed/outfile
<span class="o">&gt;</span>
bash: not_existed/outfile: No such file or directory
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><p>이에 대해 동일하게 구현했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">""</span> <span class="s2">"ls"</span> <span class="s2">"ls"</span> not_existed/outfile
heredoc&gt;
❌Error: No such file or directory: not_existed/outfile
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><h3 id="예외처리-5-outfile-이-이미-존재하지만-쓰기-권한이-없을-때">예외처리 5. <code class="language-plaintext highlighter-rouge">outfile</code> 이 이미 존재하지만 쓰기 권한이 없을 때</h3><p><code class="language-plaintext highlighter-rouge">permission denied</code> 메세지가 출력되며, exit code 는 <code class="language-plaintext highlighter-rouge">1</code> 이 반환된다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="nb">ls</span> &lt;&lt; <span class="s2">""</span> | <span class="nb">ls</span> <span class="o">&gt;&gt;</span> outfile
<span class="o">&gt;</span>
bash: outfile: Permission denied
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><p>이에 대해 동일하게 구현했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">""</span> <span class="s2">"ls"</span> <span class="s2">"ls"</span> outfile
heredoc&gt;
❌Error: permission denied: outfile
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><h3 id="예외처리-6-cmd1-이-유효하지-않고-outfile-이-존재하지-않는-경로에-있는-경우">예외처리 6. <code class="language-plaintext highlighter-rouge">cmd1</code> 이 유효하지 않고, <code class="language-plaintext highlighter-rouge">outfile</code> 이 존재하지 않는 경로에 있는 경우</h3><p><code class="language-plaintext highlighter-rouge">cmd1</code> 이 유효하지 않고, <code class="language-plaintext highlighter-rouge">outfile</code> 이 존재하지 않는 경우에는 출력 결과는 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># cmd1 이 유효하지 않고</span>
<span class="c"># outfile 이 존재하지 않는 경로에 있는 경우</span>
bash-3.2<span class="nv">$ </span><span class="s2">""</span> <span class="o">&lt;&lt;</span> <span class="sh">"</span><span class="no">HELLO</span><span class="sh">" | ls &gt;&gt; not_existed/outfile
&gt; HELLO
bash: not_existed/outfile: No such file or directory
bash: : command not found
bash-3.2</span><span class="nv">$ </span><span class="sh">echo </span><span class="nv">$?</span><span class="sh">
1
</span></pre></table></code></div></div><p>bash 기준으로는 파이프의 마지막 부분에서 오류가 먼저 출력되고, 그 다음 heredoc 부분에 대한 오류가 발생한다.</p><p>exit code 는 <code class="language-plaintext highlighter-rouge">EXIT_FAILURE</code> 에 해당하는 <code class="language-plaintext highlighter-rouge">1</code> 이 반환된다.</p><p>존재하지 않는 경로에 있는 파일을 <code class="language-plaintext highlighter-rouge">open</code> 함수로 열면 <code class="language-plaintext highlighter-rouge">-1</code> 이 반환되는데, 마지막 명령어를 실행하기 전에 <code class="language-plaintext highlighter-rouge">outfile</code> 의 <code class="language-plaintext highlighter-rouge">fd</code> 가 <code class="language-plaintext highlighter-rouge">-1</code> 인지 먼저 검사를 했다.</p><p>만약 <code class="language-plaintext highlighter-rouge">outfile</code> 이 존재하지 않는 경로에 있다면 <code class="language-plaintext highlighter-rouge">exit</code> 을 하고, 존재하는 경로에 있으면 마지막 명령어를 실행하도록 했다.</p><p>실행하면 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">"HELLO"</span> <span class="s2">""</span> <span class="s2">"ls"</span> not_existed/outfile
heredoc&gt; HELLO
❌Error: No such file or directory: not_existed/outfile
❌Error: <span class="nb">command </span>not found:
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><h3 id="예외처리-7-cmd1-가-유효하지-않고-outfile-이-이미-존재하지만-쓰기-권한이-없을-때">예외처리 7. <code class="language-plaintext highlighter-rouge">cmd1</code> 가 유효하지 않고, <code class="language-plaintext highlighter-rouge">outfile</code> 이 이미 존재하지만 쓰기 권한이 없을 때</h3><p>파이프의 마지막 쪽에서 먼저 <code class="language-plaintext highlighter-rouge">outfile</code> 에 대해 <code class="language-plaintext highlighter-rouge">permission denied</code> 가 출력되며, 이어서 <code class="language-plaintext highlighter-rouge">cmd1</code> 에 대해 <code class="language-plaintext highlighter-rouge">command not found</code> 가 출력된다. exit code 는 <code class="language-plaintext highlighter-rouge">1</code> 이 반환된다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="s2">""</span> &lt;&lt; <span class="s2">""</span> | <span class="nb">ls</span> <span class="o">&gt;&gt;</span> outfile
<span class="o">&gt;</span>
bash: outfile: Permission denied
bash: : <span class="nb">command </span>not found
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><p>이에 대해 동일하게 구현했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">""</span> <span class="s2">""</span> <span class="s2">"ls"</span> outfile
heredoc&gt;
❌Error: permission denied: outfile
❌Error: <span class="nb">command </span>not found:
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><h3 id="예외처리-8-cmd2-가-유효하지-않고-outfile-이-존재하지-않는-경로에-있는-경우">예외처리 8. <code class="language-plaintext highlighter-rouge">cmd2</code> 가 유효하지 않고, <code class="language-plaintext highlighter-rouge">outfile</code> 이 존재하지 않는 경로에 있는 경우</h3><p>이 경우에는 <code class="language-plaintext highlighter-rouge">No such file or directory</code> 메세지가 출력되며, exit code 는 <code class="language-plaintext highlighter-rouge">1</code> 이 반환된다.</p><p>이를 통해 bash 에서는 파이프의 마지막 명령어보다 <code class="language-plaintext highlighter-rouge">outfile</code> 이 우선순위가 높다는 것을 알 수 있다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="nb">ls</span> &lt;&lt; <span class="s2">""</span> | <span class="s2">""</span> <span class="o">&gt;&gt;</span> not_existed/outfile
<span class="o">&gt;</span>
bash: not_existed/outfile: No such file or directory
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><p>이에 대해 동일하게 구현했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">""</span> <span class="s2">"ls"</span> <span class="s2">""</span> not_existed/outfile
heredoc&gt;
❌Error: No such file or directory: not_existed/outfile
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><h3 id="예외처리-9-cmd2-가-유효하지-않고-outfile-이-이미-존재하지만-쓰기-권한이-없을-때">예외처리 9. <code class="language-plaintext highlighter-rouge">cmd2</code> 가 유효하지 않고, <code class="language-plaintext highlighter-rouge">outfile</code> 이 이미 존재하지만 쓰기 권한이 없을 때</h3><p>예외처리 6과 마찬가지로 명령어보다 <code class="language-plaintext highlighter-rouge">outfile</code> 이 우선순위가 높으며, <code class="language-plaintext highlighter-rouge">permission denied</code> 메세지가 출력된다. exit code 는 <code class="language-plaintext highlighter-rouge">1</code> 을 반환한다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="nb">ls</span> &lt;&lt; <span class="s2">""</span> | <span class="s2">""</span> <span class="o">&gt;&gt;</span> outfile
<span class="o">&gt;</span>
bash: outfile: Permission denied
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><p>이에 대해 동일하게 구현했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">""</span> <span class="s2">"ls"</span> <span class="s2">""</span> outfile
heredoc&gt;
❌Error: permission denied: outfile
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><h3 id="예외처리-10-cmd1-과-cmd2-모두-유효하지-않고-outfile-이-존재하지-않을-때">예외처리 10. <code class="language-plaintext highlighter-rouge">cmd1</code> 과 <code class="language-plaintext highlighter-rouge">cmd2</code> 모두 유효하지 않고, <code class="language-plaintext highlighter-rouge">outfile</code> 이 존재하지 않을 때</h3><p>앞서 살펴본 것처럼 두 번째 파이프에서는 <code class="language-plaintext highlighter-rouge">outfile</code> 이 우선순위가 높기 때문에 <code class="language-plaintext highlighter-rouge">outfile</code> 을 찾을 수 없다면 이에 해당하는 오류 메세지를 출력하고, 두 번째 명령어를 실행하지 않는다. <code class="language-plaintext highlighter-rouge">outfile</code> 에 권한이 없을 때도 마찬가지이다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span><span class="s2">""</span> &lt;&lt; <span class="s2">""</span> | <span class="s2">""</span> <span class="o">&gt;&gt;</span> <span class="s2">""</span>
<span class="o">&gt;</span>
bash: : No such file or directory
bash: : <span class="nb">command </span>not found
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><p>이에 대해 동일하게 구현했다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>bash-3.2<span class="nv">$ </span>./pipex here_doc <span class="s2">""</span> <span class="s2">""</span> <span class="s2">""</span> <span class="s2">""</span>
heredoc&gt;
❌Error: No such file or directory:
❌Error: <span class="nb">command </span>not found:
bash-3.2<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></table></code></div></div><h1 id="참고자료">참고자료</h1><ul><li><a href="https://wookkingkim.tistory.com/m/entry/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C">[운영체제]멀티 프로세스 vs 멀티 스레드</a> [티스토리]<li><a href="https://selfish-developer.com/m/entry/%EC%8A%A4%ED%83%9D-%ED%9E%99-%EC%BD%94%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%98%81%EC%97%AD">스택, 힙, 코드, 데이터영역</a> [티스토리]<li><a href="https://stackoverflow.com/questions/985051/what-is-the-purpose-of-fork">What is the purpose of fork()?</a> [stackoverflow]<li><a href="https://haedallog.tistory.com/m/138">[OS] 프로세스(process)와 스레드(thread)</a> [티스토리]<li><a href="https://dheldh77.tistory.com/m/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACScheduler">[운영체제] 스케줄러(Scheduler)</a> [티스토리]</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/42seoul/'>42seoul</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/pipex/" class="post-tag no-text-decoration">pipex</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[42Seoul] pipex (3) 구현 과정 - Dev Joon&url=https://han-joon-hyeok.github.io/posts/pipex-3-solution/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[42Seoul] pipex (3) 구현 과정 - Dev Joon&u=https://han-joon-hyeok.github.io/posts/pipex-3-solution/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[42Seoul] pipex (3) 구현 과정 - Dev Joon&url=https://han-joon-hyeok.github.io/posts/pipex-3-solution/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/c-bitwise-operation-between-different-integer-sizes/">[C언어] 자료형 크기 차이로 인한 비트 연산 오류 해결 방법</a><li><a href="/posts/connect-to-ec2-without-ssh-key-using-session-manager/">[AWS] EC2 인스턴스 ssh 키 없이 터미널 접속하는 방법 (AWS Session Manager)</a><li><a href="/posts/how-to-access-geo-restricted-websites-using-mullvad-vpn/">국가 제한이 걸린 사이트에 접속하는 방법 (feat. Mullvad VPN)</a><li><a href="/posts/network-overview/">네트워크 LAN, WAN / 스위치, 라우터 / IP 주소 / 서브넷 개념 정리</a><li><a href="/posts/what-is-nat/">NAT란?</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/pipex-1-subject/"><div class="card-body"> <span class="timeago small" > Jan 30, 2023 <i class="unloaded">2023-01-30T08:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[42Seoul] pipex (1) 프로젝트 개요</h3><div class="text-muted small"><p> Mandatory part 과제 설명 쉘의 파이프(|) 명령어를 구현하는 과제 제출 파일 사용한 모든 파일 (libft 사용했을 경우 모두 포함해서 제출) 사용 가능한 함수 open, close, read, write, malloc, free, perror, strerror, access, dup, dup2, execve, exit, ...</p></div></div></a></div><div class="card"> <a href="/posts/pipex-2-functions-access/"><div class="card-body"> <span class="timeago small" > Jan 30, 2023 <i class="unloaded">2023-01-30T08:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[42Seoul] pipex (2) 허용 함수 정리 : access</h3><div class="text-muted small"><p> access #include &lt;unistd.h&gt; int access(const char *file, int mode); file 에 대해 mode 에 대한 접근이 있는지 확인하는 함수이다. mode 에 입력할 수 있는 값은 다음과 같다. R_OK : read 권한이 있는지 확인 W_OK : write 권한이 있는지 확인 ...</p></div></div></a></div><div class="card"> <a href="/posts/pipex-2-functions-dup/"><div class="card-body"> <span class="timeago small" > Jan 30, 2023 <i class="unloaded">2023-01-30T08:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[42Seoul] pipex (2) 허용 함수 정리 : dup</h3><div class="text-muted small"><p> dup #include &lt;unistd.h&gt; int dup(int fildes); 함수의 매개변수(fileds)로 전달하는 파일 디스크립터를 현재 할당할 수 있는 가장 작은 파일 디스크립터에 복사하여 반환한다. 반환값 성공 : 복사된 파일 디스크립터 번호 실패 : -1 발생한 오류에 따라 errno 가 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/pipex-2-functions-waitpid/" class="btn btn-outline-primary" prompt="Older"><p>[42Seoul] pipex (2) 허용 함수 정리 : waitpid</p></a> <a href="/posts/virtual-machine-and-docker/" class="btn btn-outline-primary" prompt="Newer"><p>가상머신과 도커의 차이</p></a></div><script src="https://utteranc.es/client.js" repo="Han-Joon-Hyeok/Han-Joon-Hyeok.github.io" issue-term="pathname" label="Comments" theme="preferred-color-scheme" crossorigin="anonymous" async> </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/han-joon-hyeok">Joon Hyeok Han</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://han-joon-hyeok.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
