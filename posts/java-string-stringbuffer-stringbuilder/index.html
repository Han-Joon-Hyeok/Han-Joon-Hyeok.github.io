<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리" /><meta name="author" content="Joon Hyeok Han" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="개요" /><meta property="og:description" content="개요" /><link rel="canonical" href="https://han-joon-hyeok.github.io/posts/java-string-stringbuffer-stringbuilder/" /><meta property="og:url" content="https://han-joon-hyeok.github.io/posts/java-string-stringbuffer-stringbuilder/" /><meta property="og:site_name" content="Dev Joon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-02-23T18:55:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Joon Hyeok Han" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Joon Hyeok Han"},"dateModified":"2026-02-16T13:05:47+09:00","datePublished":"2025-02-23T18:55:00+09:00","description":"개요","headline":"[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리","mainEntityOfPage":{"@type":"WebPage","@id":"https://han-joon-hyeok.github.io/posts/java-string-stringbuffer-stringbuilder/"},"url":"https://han-joon-hyeok.github.io/posts/java-string-stringbuffer-stringbuilder/"}</script><title>[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리 | Dev Joon</title><link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/images/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/images/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/images/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/images/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/images/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/images/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/images/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/images/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/images/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/images/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/images/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/images/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/images/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/images/favicons/manifest.json"><meta name='msapplication-config' content='/assets/images/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/images/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-SKST7KNWSJ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SKST7KNWSJ'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/profile.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dev Joon</a></div><div class="site-subtitle font-italic">성장하는 개발자, 한준혁입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Han-Joon-Hyeok" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['joonhyeok.han','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Feb 23, 2025, 6:55 PM +0900" > Feb 23, 2025 <i class="unloaded">2025-02-23T18:55:00+09:00</i> </span> by <span class="author"> Joon Hyeok Han </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Feb 16, 2026, 1:05 PM +0900" > Feb 16 <i class="unloaded">2026-02-16T13:05:47+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4101 words">22 min</span></div></div><div class="post-content"><h1 id="개요">개요</h1><p>Java에서 문자열을 다루기 위해 사용하는 클래스 3가지(String, StringBuffer, StringBuilder)에 대해 정리했습니다.</p><h1 id="string">String</h1><p>String 객체는 불변(Immutable) 객체입니다. Heap 메모리 영역 안에서 관리되며, String Constant Pool 또는 Heap 영역에 생성됩니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span> <span class="c1">// String Constant Pool에 생성</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span> <span class="c1">// Heap에 생성</span>
</pre></table></code></div></div><p>위의 코드에서 할당한 문자열이 메모리 상에서 관리되는 위치를 그림으로 표현하면 아래와 같습니다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2025/2025-02-23-java-string-stringbuffer-stringbuilder/1.png" alt="1.png" /></p><p>출처: https://deveric.tistory.com/123</p><h2 id="string-클래스는-왜-필요했을까">String 클래스는 왜 필요했을까?</h2><p>문자열을 다루기 위해 Primitive Type인 int, double, char가 아닌 String 클래스를 사용하는 이유가 뭘까요? String은 왜 Primitive Type이 아닌걸까요? 이를 이해하기 위해서는 Java 이전에 어떻게 문자열을 다루었는지 살펴볼 필요가 있습니다.</p><h3 id="c언어에서-문자열을-다루는-방법">C언어에서 문자열을 다루는 방법</h3><p>Java가 등장하기 이전에 사용했던 C언어에서는 문자열을 저장하기 위해 <code class="language-plaintext highlighter-rouge">char</code> 자료형의 배열 형태인 <code class="language-plaintext highlighter-rouge">char[]</code> 또는 포인터형 <code class="language-plaintext highlighter-rouge">char*</code> 을 사용합니다. C언어에서는 문자열 크기를 조절하기 위해 포인터를 사용하지만, 개발자가 매번 메모리를 직접 할당하고 해제해야 하는 번거로움이 있습니다. 그리고 실수로 메모리 해제를 하지 않으면 메모리 누수로 이어지기 때문에 문자열을 다룰 때는 더욱 신경을 써야 합니다.</p><p>아래의 코드는 malloc을 이용해서 Heap 영역에 동적으로 메모리를 할당하는 예시입니다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// C언어로 문자열 생성하기</span>

<span class="c1">// 문자열을 저장하기 위한 동적 메모리 할당</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>

<span class="c1">// 배열에 문자열 할당</span>
<span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'h'</span><span class="p">;</span>
<span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'i'</span><span class="p">;</span>
<span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="c1">// 문자열의 끝을 알리는 NULL 문자</span>

<span class="c1">// 문자열 출력</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span> <span class="c1">// hi</span>

<span class="c1">// 할당한 동적 메모리를 해제하지 않으면 메모리 누수 발생</span>
<span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</pre></table></code></div></div><p>고정 크기 배열을 사용하면 malloc이나 free를 사용하지 않아도 됩니다. 이 경우에는 Stack 영역에 문자열이 생성됩니다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// C언어로 문자열 생성하기</span>

<span class="c1">// 문자열을 저장하기 위한 고정 크기 배열 생성</span>
<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"hi"</span><span class="p">;</span>

<span class="c1">// 문자열 출력</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span> <span class="c1">// hi</span>
</pre></table></code></div></div><p>하지만 코드를 작성하다보면 문자열을 저장하기 위해 고정 크기 배열을 생성하는 것보다 malloc을 이용해서 동적으로 메모리를 할당하는 경우가 많습니다. 만약, 문자열의 길이를 미리 예측할 수 없어서 배열의 크기를 넉넉하게 10,000으로 설정해두었는데, 실제로는 길이가 1인 문자열만 들어온다면 9,999 만큼의 공간을 낭비하는 것입니다. 그렇기 때문에 C언어에서는 메모리를 효율적으로 사용하기 위해 개발자가 직접 동적 메모리를 관리해야 하는 부담이 있습니다.</p><h3 id="java에서-string-클래스가-문자열을-다루는-방법">Java에서 String 클래스가 문자열을 다루는 방법</h3><p>이처럼 C언어에서 문자열을 다룰 때 개발자가 동적 메모리를 관리하는 번거로움을 해결하기 위해 Java에서는 편리하게 문자열을 다룰 수 있도록 String 클래스를 제공합니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// Java에서 문자열 생성하기</span>

<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hi"</span><span class="o">;</span>
</pre></table></code></div></div><p>C언어와 비교했을 때 Java로 작성하면 코드의 양이 감소하고, String 클래스 내부에서 생성자와 소멸자를 통해 객체의 생명주기를 관리하기 때문에 개발자는 비즈니스 로직에 집중할 수 있게 되었습니다.</p><p>실제로 String 클래스의 생성자를 타고 들어가면 <code class="language-plaintext highlighter-rouge">new</code> 키워드를 이용해서 동적으로 메모리를 할당하는 것을 확인할 수 있습니다. String 객체를 생성할 때 <code class="language-plaintext highlighter-rouge">char[]</code> 자료형을 매개변수로 받은 경우에 아래와 같이 <code class="language-plaintext highlighter-rouge">StringUTF16.toBytes()</code> 메서드를 호출합니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// String 클래스</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">String</span>
    <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span><span class="o">,</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;,</span> <span class="nc">CharSequence</span><span class="o">,</span>
               <span class="nc">Constable</span><span class="o">,</span> <span class="nc">ConstantDesc</span> <span class="o">{</span>

   <span class="c1">// 문자열을 저장하기 위한 멤버 변수</span>
   <span class="nd">@Stable</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>

   <span class="c1">// ...생략...</span>

   <span class="c1">// 1. char[] 배열을 매개변수로 받는 생성자</span>
   <span class="kd">public</span> <span class="nf">String</span><span class="o">(</span><span class="kt">char</span> <span class="n">value</span><span class="o">[])</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="c1">// 2. 1번에서 호출한 생성자 this(value, 0, value.length, null)</span>
   <span class="nc">String</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">,</span> <span class="nc">Void</span> <span class="n">sig</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// ...생략</span>

      <span class="k">this</span><span class="o">.</span><span class="na">coder</span> <span class="o">=</span> <span class="no">UTF16</span><span class="o">;</span>
      <span class="c1">// 3. 동적으로 메모리 할당 받는 부분</span>
      <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="nc">StringUTF16</span><span class="o">.</span><span class="na">toBytes</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
    <span class="o">}</span>
 <span class="o">}</span>
</pre></table></code></div></div><p>StringUTF16 클래스에 정의된 <code class="language-plaintext highlighter-rouge">toBytes()</code> 메서드의 구현을 살펴보면 <code class="language-plaintext highlighter-rouge">newBytesFor()</code> 라는 메서드를 호출합니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// StringUTF16 클래스</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="nc">StringUTF16</span> <span class="o">{</span>

    <span class="c1">// 1. String 클래스의 생성자가 호출한 메서드</span>
    <span class="nd">@IntrinsicCandidate</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">toBytes</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">val</span> <span class="o">=</span> <span class="n">newBytesFor</span><span class="o">(</span><span class="n">len</span><span class="o">);</span> <span class="c1">// 동적 메모리 할당 메서드</span>
        <span class="c1">// ...생략...</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 2. 동적 메모리 할당 메서드</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">newBytesFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// ...생략...</span>

      <span class="c1">// 3. new 키워드로 heap 영역에 메모리 할당</span>
      <span class="k">return</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p>이를 통해 String 객체가 Heap 영역에서 관리되는 이유를 알 수 있습니다. 즉, String 객체는 Primitive Type가 아니며, 주소 값을 참조하는 Reference Type 입니다.</p><h2 id="string은-왜-불변immutable인가">String은 왜 불변(Immutable)인가?</h2><p>위에서 String 객체는 불변 객체라고 설명했습니다. 불변은 변하지 않는다는 의미인데, 정확히 무슨 의미일까요?</p><h3 id="리터럴로-선언한-문자열">리터럴로 선언한 문자열</h3><p>불변의 의미를 이해하기 위해 예시 코드를 함께 살펴보겠습니다.</p><p>아래와 같이 변수 2개에 동일한 문자열을 할당하고, 객체의 고유한 주소 값에 해당하는 hashCode를 출력하면 동일한 값이 출력됩니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>  <span class="c1">// 113318802</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 113318802</span>
</pre></table></code></div></div><p>메모리 구조를 그림으로 표현하면 아래와 같습니다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2025/2025-02-23-java-string-stringbuffer-stringbuilder/2.png" alt="2.png" /></p><p>String Constant Pool 영역의 메모리 주소 0x42에 문자열 <code class="language-plaintext highlighter-rouge">hello</code> 이 할당되어 있습니다. 그리고 str 변수와 str2는 동일한 주소를 참조하고 있습니다.</p><p>만약, 코드가 아래와 같이 변경되었다고 해보겠습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>  <span class="c1">// 99162322</span>

<span class="n">str</span> <span class="o">=</span> <span class="s">"world"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>  <span class="c1">// 113318802</span>
</pre></table></code></div></div><p>처음에는 str 변수는 문자열 <code class="language-plaintext highlighter-rouge">hello</code> 가 선언된 주소를 참조했지만, 문자열 <code class="language-plaintext highlighter-rouge">world</code>의 주소를 참조합니다. 그림으로 표현하면 아래와 같습니다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2025/2025-02-23-java-string-stringbuffer-stringbuilder/3.png" alt="3.png" /></p><p>즉, 변수에 다른 문자열을 할당한다고 해서 0x42 주소가 갖고 있는 값 <code class="language-plaintext highlighter-rouge">hello</code> 문자열이 <code class="language-plaintext highlighter-rouge">world</code> 로 바뀌는 것이 아니라 <code class="language-plaintext highlighter-rouge">world</code> 문자열을 갖고 있는 다른 메모리 주소(0x24)를 참조하는 것입니다. 이처럼 String 객체는 한번 생성되면 내부적으로 값을 바꾸지 않습니다.</p><p>또한, String 클래스는 문자열을 저장하기 위한 멤버 변수 value가 final 키워드로 선언되어 있습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// String 클래스</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">String</span>
    <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span><span class="o">,</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;,</span> <span class="nc">CharSequence</span><span class="o">,</span>
               <span class="nc">Constable</span><span class="o">,</span> <span class="nc">ConstantDesc</span> <span class="o">{</span>

   <span class="c1">// 문자열을 저장하기 위한 멤버 변수</span>
   <span class="nd">@Stable</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이는 객체 생성 시에 할당된 배열은 다른 배열로 대체될 수 없다는 의미입니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>

<span class="c1">// ❌ Cannot assign a value to final variable 'value'</span>
<span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">20</span><span class="o">];</span>
</pre></table></code></div></div><p>정리하면, String 객체가 불변이라는 것은 2가지 관점으로 바라볼 수 있습니다.</p><ol><li>변수에 새로운 문자열을 재할당해도 기존에 할당했던 문자열 자체가 바뀌는 것이 아닌 참조하는 메모리 주소 값이 바뀌는 것이다.<li>String 클래스 내부에서 문자를 저장하기 위한 배열은 final 키워드로 선언되어있으며, 초기화 이후에는 재할당이 불가능하다.</ol><h3 id="string이-불변이라서-좋은-점은">String이 불변이라서 좋은 점은?</h3><p>String이 불변이라서 좋은 점은 무엇이 있을까요? 아래와 같이 3가지로 정리할 수 있습니다.</p><ol><li>동일한 문자열은 같은 메모리 주소를 참조함으로써 Runtime에서 Heap 영역의 메모리를 절약할 수 있습니다.<li>멀티 스레딩 환경에서 값이 변경될 가능성이 없으므로 동기화 문제에서 자유롭습니다.<li><p>hashcode가 객체 생성 단계에서 계산되어 저장되기 때문에 hashcode를 key로 갖는 HashMap, HashSet을 사용할 때 다른 객체를 key로 했을 때보다 빠르게 사용할 수 있습니다. 예컨대, ArrayList 클래스의 <code class="language-plaintext highlighter-rouge">hashCode()</code> 구현 코드를 살펴보면, 모든 원소에 대해 <code class="language-plaintext highlighter-rouge">hashCode()</code> 를 호출해서 새롭게 계산합니다. 즉, 새로운 원소가 추가되면 <code class="language-plaintext highlighter-rouge">hashCode()</code> 호출 결과가 달라집니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 1</span>

<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 32</span>
</pre></table></code></div></div></ol><blockquote><p>다른 글을 찾아보면 String이 불변이기 때문에 보안상 안전한다는 내용이 있지만, 왜 안전한지 정확한 이유를 찾지 못해서 이 부분은 정리하지 않았습니다.</p></blockquote><h1 id="stringbuffer와-stringbuilder">StringBuffer와 StringBuilder</h1><p>String 이 외에도 문자열을 다루기 위해 사용하는 StringBuffer와 StringBuilder 클래스를 알아보겠습니다. String은 불변이지만, StringBuffer와 StringBuilder는 가변이라는 차이가 있습니다.</p><h2 id="왜-가변mutable인가">왜 가변(Mutable)인가?</h2><p>String 클래스는 내부적으로 문자를 저장하기 위해 사용하는 멤버 변수에 final 키워드를 사용했지만, 두 클래스는 그렇지 않습니다. 이는 두 클래스가 공통으로 상속 받는 AbstractStringBuilder 클래스에 선언된 멤버 변수를 살펴보면 알 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractStringBuilder</span> <span class="kd">implements</span> <span class="nc">Appendable</span><span class="o">,</span> <span class="nc">CharSequence</span> <span class="o">{</span>
  <span class="cm">/**
   * The value is used for character storage.
   */</span>
  <span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>final 키워드가 없기 때문에 문자열의 길이가 변경되어도 새로운 길이의 배열을 할당하는 것이 가능합니다. String과는 달리 Heap 영역에 하나의 객체만으로도 문자열을 자유롭게 바꾸는 것이 가능하며, 이를 가변적이라고 합니다.</p><p>값이 바뀔 때마다 새로운 객체를 만드는 String보다 훨씬 빠르기 때문에 문자열 수정이 빈번하게 발생한다면 StringBuffer나 StringBuilder를 사용하는 것이 권장됩니다.</p><h2 id="stringbuffer">StringBuffer</h2><p>StringBuffer는 멀티 스레드 환경에서 사용하는 것이 권장됩니다. 이는 메서드에서 synchronized 키워드를 사용하기 때문입니다. 예시로 <code class="language-plaintext highlighter-rouge">append()</code> 메서드의 구현은 다음과 같이 되어 있습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="nd">@IntrinsicCandidate</span>
<span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">StringBuffer</span> <span class="nf">append</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">toStringCache</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>synchronized 키워드는 여러 스레드가 동시에 같은 자원에 대해 접근하는 것을 방지해주는데, 이를 위해 자원을 사용할 수 있는지 지속적으로 확인합니다. 그래서 싱글 스레드 환경에서는 오버헤드가 발생하기 때문에 StringBuilder에 비해 미세하게 속도가 느립니다.</p><h2 id="stringbuilder">StringBuilder</h2><p>StringBuilder는 싱글 스레드 환경에서 사용하는 것이 권장됩니다. 이는 앞서 살펴본 것처럼 StringBuilder는 synchronized 키워드를 사용하지 않기 때문입니다. 마찬가지로 <code class="language-plaintext highlighter-rouge">append()</code> 메서드의 구현을 살펴보면 다음과 같습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
<span class="nd">@IntrinsicCandidate</span>
<span class="kd">public</span> <span class="nc">StringBuilder</span> <span class="nf">append</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>그렇기에 싱글 스레드 환경에서는 StringBuilder가 가장 빠른 연산 속도를 보여줍니다.</p><h3 id="string도-stringbuilder를-사용한다">String도 StringBuilder를 사용한다</h3><p>String 변수가 <code class="language-plaintext highlighter-rouge">+</code> 연산과 함께 사용될 때 컴파일러는 StringBuilder를 사용해서 String으로 변환합니다.</p><p>3개의 문자열을 합치는 상황을 살펴보겠습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">" world"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str3</span> <span class="o">=</span> <span class="s">"!"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="n">str2</span> <span class="o">+</span> <span class="n">str3</span><span class="o">;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">+</code> 연산을 사용하면 새로운 문자열이 Heap 영역에 계속 생성됩니다. 예를 들어, <code class="language-plaintext highlighter-rouge">"hello" + " world" + "!"</code> 을 수행하면 <code class="language-plaintext highlighter-rouge">"hello world"</code> 와 <code class="language-plaintext highlighter-rouge">"hello world"</code> 가 각각 새롭게 생성되어 불필요한 메모리 낭비가 발생합니다. 간단한 문자열을 합치는 경우에는 괜찮겠지만, 여러 문자열을 합치는 상황에서는 새로운 String 객체가 생성되어 메모리 공간을 많이 차지하는 문제가 발생합니다.</p><p>이러한 문제를 해결하기 위해 컴파일러는 <code class="language-plaintext highlighter-rouge">+</code> 연산이 있으면 StringBuilder로 변환해서 메모리 공간을 절약합니다. 위의 코드는 실제로 아래와 같이 변환됩니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str2</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str3</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</pre></table></code></div></div><p>만약, StringBuilder를 사용하지 않았다면 Heap 영역에 객체 2개(<code class="language-plaintext highlighter-rouge">hello world</code>, <code class="language-plaintext highlighter-rouge">hello world!</code>)가 있을 것입니다. StringBuilder는 내부적으로 <code class="language-plaintext highlighter-rouge">byte[] value</code> 변수에 할당된 객체 1개만 사용하기 때문에 메모리 공간을 효율적으로 사용할 수 있습니다.</p><p>그래서 여러 문자열을 합치는 경우에는 <code class="language-plaintext highlighter-rouge">+</code> 연산보다 StringBuffer나 StringBuilder를 사용하는 것이 속도 향상과 메모리 관리에 유리합니다.</p><h2 id="멀티-스레드-환경에서-비교">멀티 스레드 환경에서 비교</h2><p>문자를 10,000번 추가하는 스레드 2개를 실행하면 StringBuffer 객체에는 정확하게 2만 개의 문자가 저장되지만, StringBuilder는 동기화되지 않아 일부 문자가 추가되지 않을 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuffer</span> <span class="n">stringBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="nc">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">stringBuffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">stringBuffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>

                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"StringBuffer.length: "</span><span class="o">+</span> <span class="n">stringBuffer</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="c1">// thread safe 함</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"StringBuilder.length: "</span><span class="o">+</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="c1">// thread unsafe 함</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>출력 결과는 다음과 같습니다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>StringBuffer.length: 20000
StringBuilder.length: 19792
</pre></table></code></div></div><p>따라서 멀티 스레드 환경에서는 StringBuffer를 사용해야 안전하게 문자열을 처리할 수 있습니다.</p><h1 id="성능-비교">성능 비교</h1><p>각 클래스마다 연산 횟수에 따른 수행 시간을 비교한 그래프는 아래와 같습니다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2025/2025-02-23-java-string-stringbuffer-stringbuilder/4.png" alt="4.png" /></p><p>출처: <a href="https://inpa.tistory.com/entry/JAVA-%E2%98%95-String-StringBuffer-StringBuilder-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90">https://inpa.tistory.com/entry/JAVA-☕-String-StringBuffer-StringBuilder-차이점-성능-비교</a></p><p>StringBuilder가 가장 빠르며, String이 가장 느린 것을 확인할 수 있습니다.</p><h1 id="정리">정리</h1><div class="table-wrapper"><table><thead><tr><th> <th><strong>String</strong><th><strong>StringBuffer</strong><th><strong>StringBuilder</strong><tbody><tr><td>가변 여부<td>불변<td>가변<td>가변<tr><td>스레드 세이프<td>O<td>O<td>X<tr><td>연산 속도<td>느림<td>빠름<td>아주 빠름<tr><td>사용 시점<td>문자열 추가 연산이 적고, 스레드 세이프 환경<td>문자열 추가 연산이 많고, 스레드 세이프 환경<td>문자열 추가 연산이 많고, 빠른 연산 필요</table></div><h1 id="참고자료">참고자료</h1><ul><li><a href="https://readystory.tistory.com/139">Java의 String 이야기(1) - String은 왜 불변(Immutable)일까?</a> [티스토리]<li><a href="https://deveric.tistory.com/123">[Java] 많이 헷갈려하는 String constant pool과 Runtime Constant pool, Class file constant pool</a> [티스토리]<li><a href="https://inpa.tistory.com/entry/JAVA-%E2%98%95-String-StringBuffer-StringBuilder-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90">☕ 자바 String / StringBuffer / StringBuilder 차이점 &amp; 성능 비교</a> [티스토리]</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/java/'>java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리 - Dev Joon&url=https://han-joon-hyeok.github.io/posts/java-string-stringbuffer-stringbuilder/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Java] 문자열 클래스 String, StringBuffer, StringBuilder 정리 - Dev Joon&u=https://han-joon-hyeok.github.io/posts/java-string-stringbuffer-stringbuilder/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://han-joon-hyeok.github.io/posts/java-string-stringbuffer-stringbuilder/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Nest-js-google-typescript-style-with-eslint-and-prettier/">[Nest.js] 협업을 위한 Google TyepScript Style 을 ESLint, Prettier 에 간단하게 적용하기</a><li><a href="/posts/Next-js-google-typescript-style-with-eslint-and-prettier/">[Next.js] 협업을 위한 Google TyepScript Style 을 ESLint, Prettier 에 간단하게 적용하기</a><li><a href="/posts/ubuntu-file-write-permission-denied/">[Linux] 파일 write 작업 시 PermissionError: [Errno 13] Permission denied 오류 해결</a><li><a href="/posts/what-is-arp/">ARP 개념 정리</a><li><a href="/posts/ubuntu-python-crontab-not-working/">[Linux] python 을 crontab 으로 실행하도록 했는데 실행되지 않는 이유 (feat. 상대경로, 절대경로)</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">data structure</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/m1-mac-how-to-install-java-11/"><div class="card-body"> <span class="timeago small" > Nov 19, 2023 <i class="unloaded">2023-11-19T00:30:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Java] Mac M1 에서 Java11 설치하기</h3><div class="text-muted small"><p> 설치 방법 Mac 에는 Java 가 기본으로 설치되어 있지 않다. 그래서 직접 설치해주어야 한다. brew 를 이용해서 설치하기 Homebrew 를 이용하면 간단하게 설치할 수 있다. 우선 아래의 명령어를 실행해서 설치할 수 있는 Java 가 있는 지 확인한다. openjdk 뒤에 버전을 명시해주면 된다. brew s...</p></div></div></a></div><div class="card"> <a href="/posts/gradle-and-build-gradle/"><div class="card-body"> <span class="timeago small" > Nov 19, 2023 <i class="unloaded">2023-11-19T03:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Java] Gradle 과 build.gradle 파일은 무엇일까?</h3><div class="text-muted small"><p> 인프런의 &lt;스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술&gt; 강의를 듣고 궁금한 내용을 찾아서 정리한 내용입니다. Gradle Gradle 은 Java 로 작성된 코드를 하나의 완성된 프로그램으로 만들어 주는 빌드 도구이다. 빌드 과정에는 Java 코드를 바이트 코드로 변환하는 컴파일링과 여러 코드와 ...</p></div></div></a></div><div class="card"> <a href="/posts/java-spring-problem-occured-configuring-root-project/"><div class="card-body"> <span class="timeago small" > Mar 4, 2024 <i class="unloaded">2024-03-04T17:35:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Java Spring] A problem occured configuring root project 오류 해결 방법</h3><div class="text-muted small"><p> 실행 환경 OS : MacOS(Intel) Sonoma 14.2.1 IntelliJ : Ultimate 2023.2.5 문제 상황 스프링 프로젝트를 실행하려고 했지만 A problem occured configuring root project 으로 시작하는 오류가 발생했다. 문제 원인 스프링 프로젝트 세팅 시 자바 17 버전을 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-dependency-injection-and-inversion-of-control/" class="btn btn-outline-primary" prompt="Older"><p>[Spring] 의존성 주입(DI)과 제어의 역전(IoC) 개념 정리</p></a> <a href="/posts/spring-aop/" class="btn btn-outline-primary" prompt="Newer"><p>[Spring] AOP 개념 정리</p></a></div><script src="https://utteranc.es/client.js" repo="Han-Joon-Hyeok/Han-Joon-Hyeok.github.io" issue-term="pathname" label="Comments" theme="preferred-color-scheme" crossorigin="anonymous" async> </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://github.com/han-joon-hyeok">Joon Hyeok Han</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">data structure</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://han-joon-hyeok.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
