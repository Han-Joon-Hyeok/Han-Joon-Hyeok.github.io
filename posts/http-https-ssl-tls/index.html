<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="HTTP와 HTTPS, 그리고 SSL/TLS" /><meta name="author" content="Joon Hyeok Han" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="HTTP 와 HTTPS" /><meta property="og:description" content="HTTP 와 HTTPS" /><link rel="canonical" href="https://han-joon-hyeok.github.io/posts/http-https-ssl-tls/" /><meta property="og:url" content="https://han-joon-hyeok.github.io/posts/http-https-ssl-tls/" /><meta property="og:site_name" content="Dev Joon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-05T13:05:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="HTTP와 HTTPS, 그리고 SSL/TLS" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Joon Hyeok Han" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Joon Hyeok Han"},"dateModified":"2023-04-05T13:05:00+09:00","datePublished":"2023-04-05T13:05:00+09:00","description":"HTTP 와 HTTPS","headline":"HTTP와 HTTPS, 그리고 SSL/TLS","mainEntityOfPage":{"@type":"WebPage","@id":"https://han-joon-hyeok.github.io/posts/http-https-ssl-tls/"},"url":"https://han-joon-hyeok.github.io/posts/http-https-ssl-tls/"}</script><title>HTTP와 HTTPS, 그리고 SSL/TLS | Dev Joon</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-SKST7KNWSJ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SKST7KNWSJ'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dev Joon</a></div><div class="site-subtitle font-italic">성장하는 개발자, 한준혁입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Han-Joon-Hyeok" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['joonhyeok.han','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>HTTP와 HTTPS, 그리고 SSL/TLS</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>HTTP와 HTTPS, 그리고 SSL/TLS</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 5, 2023, 1:05 PM +0900" > Apr 5, 2023 <i class="unloaded">2023-04-05T13:05:00+09:00</i> </span> by <span class="author"> Joon Hyeok Han </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3791 words">21 min</span></div></div><div class="post-content"><h1 id="http-와-https">HTTP 와 HTTPS</h1><h2 id="http">HTTP</h2><p>HTTP 는 HyperText Transfer Protocol 의 약자로, 하이퍼텍스트를 전송하기 위해 사용되는 통신 규약(Protocol)이다.</p><p>즉, 인터넷에서 HTML 과 같은 문서를 클라이언트(사용자)의 웹 브라우저가 웹 서버(서비스 제공자)에 요청하거나 웹 서버가 클라이언트에서 응답을 보낼 때 지켜야 하는 규칙(프로토콜)을 의미한다.</p><p>여기서 프로토콜이란 간단하게 정해진 규칙 또는 양식이라 생각하면 된다. 택배를 주고 받을 때 정해진 송장 양식에 올바르게 작성해야 문제없이 잘 주고 받을 수 있는 것과 비슷하다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/1.png" alt="1.png" /></p><p>HTTP 서버(웹 서버)는 80번 포트에서 서비스를 대기하고 있다가 클라이언트(웹 브라우저)가 TCP 80번 포트를 사용해 연결하면 서버는 요청에 응답하면서 자료를 전송한다.</p><h3 id="요청-메세지request-message">요청 메세지(request message)</h3><p>클라이언트가 서버에 요청(request)을 할 때는 아래와 같은 내용을 담아서 보낸다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/2.png" alt="2.png" /></p><p>출처: <a href="http://www.tcpipguide.com/free/t_HTTPRequestMessageFormat.htm">HTTP Request Message Format</a> [tcpipguide]</p><p>포함되는 내용을 추려서 정리하면 아래와 같다.</p><ul><li>요청하는 리소스(위의 사진에서는 <code class="language-plaintext highlighter-rouge">/index.html</code>)<li>어떤 메서드를 사용할지(GET, POST, DELETE, PUT 등)<li>HTTP 버전 정보<li>요청을 보내는 도메인 이름(현재 클라이언트가 접속한 사이트의 주소)</ul><h3 id="응답-메세지response-message">응답 메세지(response message)</h3><p>서버는 클라이언트가 요청한 것에 대해 응답(response)할 때는 아래와 같은 내용을 담아서 보낸다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/3.png" alt="3.png" /></p><p>출처: <a href="http://www.tcpipguide.com/free/t_HTTPRequestMessageFormat.htm">HTTP Request Message Format</a> [tcpipguide]</p><ul><li>HTTP Status code : 응답 처리에 대한 결과 (200 OK = 정상)<li>Message Body: 요청한 파일의 내용</ul><h2 id="https">HTTPS</h2><p>HTTP 는 정보를 텍스트로 주고 받기 때문에 네트워크에서 전송 신호를 가로챌 가능성이 존재하며, 데이터 유출이 발생할 수 있는 보안 취약점이 있다.</p><p>데이터 유출이 발생할 수 있는 이유는 패킷이 요청한 서버에 도달하기 위해 거쳐가야 하는 수 많은 공유기, 네트워크 장비가 존재하기 때문이다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/4.png" alt="4.png" /></p><p>출처: <a href="https://www.geeksforgeeks.org/traceroute-in-network-layer/">Traceroute in Network Layer</a> [geeksforgeeks]</p><p>누군가 패킷 내부를 확인해서 민감한 개인 정보를 가로챌 수도 있고, 클라이언트 입장에서는 누군가 패킷 내부를 확인했는지 여부를 알 수 없다는 문제점이 있다.</p><p>또는, 중간에 누군가 서버인척 위장하여 클라이언트의 패킷을 가로채서 응답을 보내줄 수도 있다. (<a href="https://namu.wiki/w/ARP%20%EC%8A%A4%ED%91%B8%ED%95%91">ARP 스푸핑</a>)</p><p>실제로 macOS 환경에서 구글 서버 IP 주소인 8.8.8.8 에 요청을 보내보면 수 많은 경로를 거쳐가는 것을 확인할 수 있다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="nv">$ </span>traceroute 8.8.8.8
traceroute to 8.8.8.8 <span class="o">(</span>8.8.8.8<span class="o">)</span>, 64 hops max, 52 byte packets
1  10.31.254.254 <span class="o">(</span>10.31.254.254<span class="o">)</span>  1.076 ms  0.595 ms  0.510 ms
2  nat <span class="o">(</span>10.60.1.1<span class="o">)</span>  0.168 ms  0.169 ms  0.231 ms
3  <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>
4  112.189.14.85 <span class="o">(</span>112.189.14.85<span class="o">)</span>  0.766 ms  0.623 ms
  112.189.13.85 <span class="o">(</span>112.189.13.85<span class="o">)</span>  0.857 ms
5  <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>
6  112.174.90.10 <span class="o">(</span>112.174.90.10<span class="o">)</span>  8.583 ms
  112.174.90.62 <span class="o">(</span>112.174.90.62<span class="o">)</span>  5.806 ms
  112.174.90.38 <span class="o">(</span>112.174.90.38<span class="o">)</span>  7.515 ms
7  112.174.84.18 <span class="o">(</span>112.174.84.18<span class="o">)</span>  7.874 ms
  112.174.84.14 <span class="o">(</span>112.174.84.14<span class="o">)</span>  6.282 ms
  112.174.84.30 <span class="o">(</span>112.174.84.30<span class="o">)</span>  6.419 ms
8  142.250.165.78 <span class="o">(</span>142.250.165.78<span class="o">)</span>  28.176 ms
  72.14.243.228 <span class="o">(</span>72.14.243.228<span class="o">)</span>  32.753 ms
  142.250.165.78 <span class="o">(</span>142.250.165.78<span class="o">)</span>  28.055 ms
9  <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>
10  dns.google <span class="o">(</span>8.8.8.8<span class="o">)</span>  29.805 ms  31.165 ms  30.371 ms
</pre></table></code></div></div><p>이처럼 HTTP 가 가진 문제점을 해결하기 위해 HTTP 에 SSL(Secure Socket Layer)을 추가한 것이 HTTPS 이다.</p><p>HTTPS 를 사용하면 서버와 클라이언트 사이의 모든 통신 내용이 암호화된다.</p><h1 id="sslsecure-socket-layer">SSL(Secure Socket Layer)</h1><p>SSL 은 넷스케이프에서 개발한 인터넷 보안 프로토콜이다.</p><p>SSL 1.0 은 공개되지 않았지만, SSL 2.0 은 1995년에, SSL 3.0 은 1996년에 발표되었다.</p><p>SSL 은 기업이 만든 프로토콜이기 때문에 독점의 우려가 있었고, 인터넷 관련 기술을 표준화하는 IETF 에서 SSL 3.0 을 TLS 1.0 로 발표하였다. (TLS : Transport Layer Security 의 줄임말)</p><p>SSL 및 TLS 의 버전 발표 연도는 아래와 같다.</p><div class="table-wrapper"><table><thead><tr><th>버전<th>연도<tbody><tr><td>SSL 1.0<td>?<tr><td>SSL 2.0<td>1995<tr><td>SSL 3.0<td>1996<tr><td>TLS 1.0<td>1999<tr><td>TLS 1.1<td>2006<tr><td>TLS 1.2<td>2008<tr><td>TLS 1.3<td>2018</table></div><p>엄밀히 말하면 SSL 은 TLS 와 다르지만, 큰 흐름에서 보았을 때 TLS 가 SSL 을 계승했다는 점에서 TLS 와 SSL 은 동일한 의미에서 사용하고 있다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/5.png" alt="5.png" /></p><p>출처: <a href="https://www.lesstif.com/ws/ssl-tls-https-43843962.html">SSL/TLS 와 HTTPS</a> [lessif]</p><p>TLS 는 전송 계층(Transport layer)의 암호화 방식이기 때문에 HTTP 뿐만 아니라 FTP, XMPP 등 응용 계층 프로토콜의 종류에 상관없이 사용할 수 있다는 장점이 있다. 또한 인증, 암호화, 무결성을 보장한다.</p><ul><li>암호화 : 데이터를 제 3자가 볼 수 없도록 숨긴다.<li>인증 : 정보를 교환하는 당사자가 정보를 요청한 당사자임을 보장한다.<li>무결성 : 데이터가 바뀌지 않고 원본 그대로 전달</ul><h2 id="tls-handshake">TLS Handshake</h2><p>서버와 클라이언트는 데이터를 주고 받기 전에 서로 연결할 수 있는 상태인지 확인해야 한다.</p><p>이를 Handshake(악수) 라 하며, TLS 는 아래와 같은 과정을 거쳐 연결이 이루어진다.</p><p>클라이언트는 서버의 인증서를 받아 서버의 무결성을 확인한다. 만약, 신뢰할 수 있는 서버라는 것을 확인하면 클라이언트는 암호화 통신에 사용할 대칭키를 서버의 공개키로 암호화 하여 전달한다. 이 과정을 TLS Handshake 이다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/6.png" alt="6.png" /></p><p>출처: <a href="https://babbab2.tistory.com/7">TLS(SSL) - 3. Handshake</a> [티스토리]</p><p>TLS 를 이용한 통신은 위의 그림과 같은 과정을 거쳐서 이루어진다.</p><h3 id="1-clienthello">1. ClientHello</h3><p>클라이언트는 서버에 ClientHello 메세지를 전송한다. 패킷에는 아래와 같은 정보들이 담긴다.</p><ul><li>클라이언트에서 사용하는 TLS 버전<li><p>Cipher Suites(클라이언트가 지원하는 암호화 방식) : 서버와 클라이언트가 지원하는 암호화 방식이 다를 수 있기 때문에 handshake 를 통해 어떤 암호화 방식을 사용할 지 정한다. 구체적으로는 아래와 같은 항목들이 포함된다.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  SSL/TLS_<span class="o">(</span>A<span class="o">)</span>_<span class="o">(</span>B<span class="o">)</span>_WITH_<span class="o">(</span>C<span class="o">)</span>_<span class="o">(</span>D<span class="o">)</span>_<span class="o">(</span>E<span class="o">)</span>
  - <span class="o">(</span>A<span class="o">)</span> : 키 교환 암호 알고리즘
  - <span class="o">(</span>B<span class="o">)</span> : 인증 알고리즘
  - <span class="o">(</span>C<span class="o">)</span> : 대칭 암호 알고리즘
  - <span class="o">(</span>D<span class="o">)</span> : 블록 암호 운용 방식
  - <span class="o">(</span>E<span class="o">)</span> : 해시 알고리즘
</pre></table></code></div></div><ul><li>키 교환 알고리즘 : 서버와 클라이언트가 키를 교환하는 알고리즘<li>인증 알고리즘 : 서버와 클라이언트가 교환한 인증서를 확인하는 알고리즘<li>대칭 암호 알고리즘 : 실제 데이터를 암호화 하는 알고리즘<li>블록 암호 운용 방식 : 데이터를 암호화할 때 한번에 암호화 하지 않고 블록 단위로 하는데, 블록된 암호화 패킷을 조합하여 데이터를 추측하는 것을 방지하기 위한 방식<li>해시 알고리즘 : 서로 상대방이 암호화한 것이 맞는지 확인하는 알고리즘</ul><li>Client Random Data(클라이언트에서 생성한 난수. 대칭키 생성 시 사용)<li>세션 ID : 동일한 클라이언트와 서버가 매번 Handshake 를 한다면 많은 시간이 소요될 것이다. 그래서 최초의 Handshake 만 Full handshake(서버 인증서 확인, 암호화 방식 선정, 대칭키 교환 등)를 수행하고, 이후에는 세션 ID 만 확인해서 통신을 한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/7.png" alt="7.png" /></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>출처: [TLS(SSL) - 3. Handshake](https://babbab2.tistory.com/7) [티스토리]

- 최초 Handshake 에서 클라이언트의 세션 ID 는 0 이다.
- 이후 ServerHello 메세지를 통해 서버는 세션 ID 를 보낸다.
- 클라이언트는 서버가 보낸 세션 ID 를 로컬에 저장한다.
- 이후 같은 서버와 Handshake 를 하면, 이전에 로컬에 저장한 세션 ID 를 전송한다.
- 서버는 세션 ID 를 확인해서 다시 사용해도 괜찮으면 ServerHello 에 같은 세션 ID 를 보낸다. - SNI(Server Name Indication, 서버 이름) : 서버의 이름(ex. www.naver.com)을 표시하는 부분이다.
- 기존에는 IP 주소와 도메인이 1:1 대응되었기 때문에 문제가 없었다.
- 하지만, 최근에는 IP 주소 하나에 여러 도메인을 연결할 수 있기 때문에 문제가 발생한다. 서버에서 발행한 인증서 하나에 모든 도메인을 명시하는 것은 불가능하며, 도메인마다 인증서를 발급하는 것도 비효율적이다.
- 따라서 IP 주소에 접속할 때, 어떤 도메인에 접속하는 지 명시하는 부분이 SNI 이다.
- 이를 이용하면 물리적으로 동일한 서버에 존재하는 각기 다른 도메인들이 서로 다른 TLS 인증서를 적용할 수 있다.
</pre></table></code></div></div><h3 id="2-serverhello">2. ServerHello</h3><p>클라이언트가 보낸 ClientHello 에 대해 서버에서 응답하는 메세지이다.</p><p>포함되는 정보는 ClientHello 와 유사하며, 구체적으로는 아래와 같다.</p><ul><li>서버에서 사용하는 TLS 버전<li>Selected Suite : 클라이언트가 보낸 암호화 방식 중에서 서버가 사용 가능한 암호화 방식이다.<li>Server Random Data : 서버에서 생성한 난수이다. 클라이언트와 동일하게 대칭키를 만들기 위해 사용한다.<li>세션 ID : ClientHello 에 세션 ID 가 0 으로 왔다면 새로 세션 ID 를 생성해서 보내고, 0 이 아니라면 해당 세션 ID 가 유효한지 확인하고 새로 발급해주거나 클라이언트가 보낸 세션 ID 를 그대로 보내준다.<li>SNI : 서버에서는 비워서 보낸다.</ul><h3 id="3-server-certificate">3. Server Certificate</h3><p>서버의 인증서를 클라이언트에게 보내는 과정이다.</p><p>인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 요청한 서버가 맞는지 보장하는 것이다.</p><p>이러한 인증서를 발급하는 기업들을 CA(Certificate Authority) 또는 Root Certificate 라고 한다. CA 는 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있다.</p><p>TLS 를 통해 암호화 통신을 제공하려는 서비스는 CA 를 통해 인증서를 구입해야 한다.</p><p>만약 개발 또는 사적인 목적을 위해 TLS 를 이용하고자 한다면, 자신이 직접 CA 역할을 할 수도 있다. 하지만 공인된 인증서가 아니기 때문에 브라우저에서는 아래와 같은 경고를 띄울 수 있다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2023/2023-04-05-http-https-ssl-tls/8.png" alt="8.png" /></p><p>출처: <a href="https://www.opentutorials.org/course/228/4894">HTTPS와 SSL 인증서</a> [생활코딩]</p><p>인증서에는 아래와 같은 정보가 포함되어 있다.</p><ol><li>서비스의 정보 : 인증서를 발급한 CA, 서비스의 도메인 등<li>서버 측 공개키 : 공개키의 내용, 공개키의 암호화 방법</ol><p>1번은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용이 담겨있다.</p><p>2번은 서버와 통신할 때 사용할 공개키와 그 공개키의 암호화 방법들의 정보를 담고 있다.</p><p>위의 정보들은 서비스가 CA 로부터 인증서를 구입할 때 제출해야 하며, CA 에 의해 암호화 된다.</p><p>이때 사용하는 암호화 기법은 공개키 방식이다. CA 는 자신의 CA 비공개키를 이용해서 서버가 제출한 인증서를 암호화 한다.</p><p>브라우저는 내부적으로 CA 의 리스트를 미리 파악하고 있다.</p><p>즉, 브라우저 소스 코드 안에는 CA 의 리스트가 들어있다는 것이다. 브라우저가 미리 파악하고 있는 CA 의 리스트에 포함되어야만 공인된 CA 가 될 수 있다.</p><p>그래서 브라우저는 CA 의 리스트와 함께 CA 의 공개키를 이미 알고 있다.</p><p>클라이언트의 브라우저는 서버로부터 받은 인증서가 공인된 CA 목록에 있는지 확인하고, 브라우저가 가지고 있는 공개키로 인증서를 복호화 한다. 복호화 된 인증서에는 서버의 공개키가 담겨있다.</p><p>그러면 이전에 서버로부터 받은 난수와 클라이언트가 생성한 난수를 조합하고 pre master secret 라는 키를 생성한다. 이는 앞으로 클라이언트와 서버가 암호화 통신에 사용할 대칭키의 재료가 되는 키이다.</p><h3 id="4-server-hello-done">4. Server Hello Done</h3><p>서버가 클라이언트에게 보낼 메세지를 모두 보냈다는 의미이다.</p><h3 id="5-client-key-exchange">5. Client Key Exchange</h3><p>클라이언트는 3번에서 만든 pre master secret 키를 서버의 공개키로 암호화하여 서버에 전송한다.</p><h3 id="6-key-generation">6. Key Generation</h3><p>서버는 클라이언트가 전송한 pre master secret 키를 서버의 개인키로 복호화한다. 그리고 클라이언트와 서버는 일련의 과정을 거쳐서 pre master secret 키를 master secret 키를 생성한다.</p><p>master secret 는 session key 를 생성하는데, session key 를 이용해 서버와 클라이언트는 통신을 암호화 하는데 사용한다.</p><h3 id="7-cipher-spec-exchange">7. Cipher Spec Exchange</h3><p>이제 서버와 클라이언트가 주고 받는 모든 메세지는 정해진 알고리즘과 session key 를 이용해서 암호화 하겠다고 서로 알려준다.</p><h3 id="8-finished">8. Finished</h3><p>그 다음 Finished 메세지를 보내서 각자 handshake 과정이 끝났음을 알린다.</p><h1 id="참고자료">참고자료</h1><ul><li><a href="https://seunghyun90.tistory.com/41">HTTP 개념 및 주요 내용 정리</a> [티스토리]<li><a href="https://rachel-kwak.github.io/2021/03/08/HTTPS.html">HTTPS란? (동작방식, 장단점)</a> [github.io]<li><a href="https://youtu.be/EPcQqkqqouk">[10분 테코톡] 👶에단의 TLS</a> [youtube]<li><a href="https://m.blog.naver.com/brickbot/220441375126">IP/ARP 스푸핑 (Spoofing)공격은 무엇이며 공격은 어떻게 실행되는지를 학습합니다.</a> [네이버 블로그]<li><a href="https://www.techtarget.com/searchsecurity/definition/Secure-Sockets-Layer-SSL">SSL (secure sockets layer)</a> [TechTarget]<li><div class="table-wrapper"><table><tbody><tr><td>[TLS Handshake는 어떻게 진행되는가?<td>Session Key](https://sunrise-min.tistory.com/entry/TLS-Handshake%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A7%84%ED%96%89%EB%90%98%EB%8A%94%EA%B0%80) [티스토리]</table></div><li><a href="https://run-it.tistory.com/30">SSL/TLS, Cipher suite란?</a> [티스토리]<li><a href="https://www.opentutorials.org/course/228/4894">HTTPS와 SSL 인증서</a> [생활코딩]<li><a href="https://babbab2.tistory.com/7">TLS(SSL) - 3. Handshake</a> [티스토리]</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/docker/'>docker</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/docker/" class="post-tag no-text-decoration">docker</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=HTTP와 HTTPS, 그리고 SSL/TLS - Dev Joon&url=https://han-joon-hyeok.github.io/posts/http-https-ssl-tls/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=HTTP와 HTTPS, 그리고 SSL/TLS - Dev Joon&u=https://han-joon-hyeok.github.io/posts/http-https-ssl-tls/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=HTTP와 HTTPS, 그리고 SSL/TLS - Dev Joon&url=https://han-joon-hyeok.github.io/posts/http-https-ssl-tls/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/c-bitwise-operation-between-different-integer-sizes/">[C언어] 자료형 크기 차이로 인한 비트 연산 오류 해결 방법</a><li><a href="/posts/connect-to-ec2-without-ssh-key-using-session-manager/">[AWS] EC2 인스턴스 ssh 키 없이 터미널 접속하는 방법 (AWS Session Manager)</a><li><a href="/posts/how-to-access-geo-restricted-websites-using-mullvad-vpn/">국가 제한이 걸린 사이트에 접속하는 방법 (feat. Mullvad VPN)</a><li><a href="/posts/network-overview/">네트워크 LAN, WAN / 스위치, 라우터 / IP 주소 / 서브넷 개념 정리</a><li><a href="/posts/what-is-nat/">NAT란?</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/next-js-env-variable-undefined-with-docker/"><div class="card-body"> <span class="timeago small" > Aug 28, 2023 <i class="unloaded">2023-08-28T01:25:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>next.js 빌드 시 환경 변수가 undefined 인 문제 해결 (feat. docker-compose)</h3><div class="text-muted small"><p> 문제 상황 Next.js 로 작성한 프론트엔드 프로젝트를 docker 와 docker-compose 를 이용해서 컨테이너로 올리고 싶었다. 개발할 때는 .env 파일을 docker-compose 를 통해서 넣어줬고, 환경 변수를 잘 인식했다. 하지만 배포를 위해 npm run build 명령어로 빌드하고 npm run start 로 실행해보니 환...</p></div></div></a></div><div class="card"> <a href="/posts/virtual-machine-and-docker/"><div class="card-body"> <span class="timeago small" > Apr 5, 2023 <i class="unloaded">2023-04-05T12:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>가상머신과 도커의 차이</h3><div class="text-muted small"><p> 가상머신과 도커의 차이 하나의 물리 서버를 효율적으로 사용하기 위해 ‘서버 가상화 기술’이 발전했다. 가상머신과 컨테이너는 모두 서버 가상화 기술을 적용한 것이다. 하지만 어떤 가상화 소프트웨어를 사용하는지, 어떤 시스템 레벨을 가상화하는지에 차이가 존재한다. 가상화 가상화는 컴퓨터에서 하나의 물리 하드웨어 시스템에서 여러 가상 시스템을 실행...</p></div></div></a></div><div class="card"> <a href="/posts/types-of-docker-network/"><div class="card-body"> <span class="timeago small" > Apr 5, 2023 <i class="unloaded">2023-04-05T12:48:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Docker network 개념 정리</h3><div class="text-muted small"><p> Docker network 개념 도커 컨테이너는 격리된 환경에서 실행되기 때문에 기본적으로 다른 컨테이너와 통신을 할 수 없다. 그래서 여러 컨테이너끼리 통신을 하기 위해서는 같은 도커 네트워크에 연결해야 한다. 도커 네트워크는 기본적으로 가상 네트워크 인터페이스를 생성한다. Linux bridge 도커는 linux bridge 를 이용해서 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/types-of-docker-network/" class="btn btn-outline-primary" prompt="Older"><p>Docker network 개념 정리</p></a> <a href="/posts/forward-proxy-and-reverse-proxy/" class="btn btn-outline-primary" prompt="Newer"><p>Forward Proxy와 Reverse Proxy</p></a></div><script src="https://utteranc.es/client.js" repo="Han-Joon-Hyeok/Han-Joon-Hyeok.github.io" issue-term="pathname" label="Comments" theme="preferred-color-scheme" crossorigin="anonymous" async> </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/han-joon-hyeok">Joon Hyeok Han</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://han-joon-hyeok.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
