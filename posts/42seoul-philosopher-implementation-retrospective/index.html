<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.3.0" /><meta property="og:title" content="[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고" /><meta name="author" content="Joon Hyeok Han" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="플로우차트" /><meta property="og:description" content="플로우차트" /><link rel="canonical" href="https://han-joon-hyeok.github.io/posts/42seoul-philosopher-implementation-retrospective/" /><meta property="og:url" content="https://han-joon-hyeok.github.io/posts/42seoul-philosopher-implementation-retrospective/" /><meta property="og:site_name" content="Dev Joon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-10-13T14:20:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Joon Hyeok Han" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Joon Hyeok Han"},"dateModified":"2022-10-13T14:20:00+09:00","datePublished":"2022-10-13T14:20:00+09:00","description":"플로우차트","headline":"[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고","mainEntityOfPage":{"@type":"WebPage","@id":"https://han-joon-hyeok.github.io/posts/42seoul-philosopher-implementation-retrospective/"},"url":"https://han-joon-hyeok.github.io/posts/42seoul-philosopher-implementation-retrospective/"}</script><title>[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고 | Dev Joon</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-SKST7KNWSJ"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SKST7KNWSJ'); }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}}); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dev Joon</a></div><div class="site-subtitle font-italic">성장하는 개발자, 한준혁입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Han-Joon-Hyeok" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['joonhyeok.han','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Oct 13, 2022, 2:20 PM +0900" > Oct 13, 2022 <i class="unloaded">2022-10-13T14:20:00+09:00</i> </span> by <span class="author"> Joon Hyeok Han </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6705 words">37 min</span></div></div><div class="post-content"><h1 id="플로우차트">플로우차트</h1><h2 id="mandatory">Mandatory</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/1.png" alt="1.png" /></p><h2 id="bonus">Bonus</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/2.png" alt="2.png" /></p><h1 id="식사하는-철학자-문제">식사하는 철학자 문제</h1><p>식사하는 철학자 문제는 운영체제에서 교착상태(Deadlock)을 설명하기 위한 문제이다.</p><h2 id="교착상태">교착상태</h2><p>교착상태란 운영체제 또는 소프트웨어의 잘못된 자원 관리로 두 개 이상의 작업이 서로의 작업이 끝나기만을 기다려서 결과적으로 아무 것도 완료되지 못하는 상태를 의미한다. 조금 더 쉽게 표현하면 이러지도 저러지도 못하는 상태이다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/3.png" alt="3.png" /></p><p>출처: <a href="https://pubul.tistory.com/36">티스토리</a></p><h2 id="교착상태-발생-조건">교착상태 발생 조건</h2><h3 id="1-상호배제mutual-exclusion">1. 상호배제(Mutual exclusion)</h3><p>한 번에 프로세스 하나만 해당 자원을 사용할 수 있는데, 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.</p><h3 id="2-점유대기hold-and-wait">2. 점유대기(Hold and wait)</h3><p>자원을 가지고 있는 상태에서 다른 프로세스가 사용하는 자원의 반납을 기다려야 한다.</p><h3 id="3-비선점no-preemption">3. 비선점(No preemption)</h3><p>다른 프로세스에 할당된 자원을 강제로 빼앗을 수 없다.</p><h3 id="4-순환대기circular-wait">4. 순환대기(Circular wait)</h3><p>대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.</p><h2 id="교착상태-해결-방법">교착상태 해결 방법</h2><h3 id="1-예방prevention">1. 예방(Prevention)</h3><p>교착상태 발생 조건 4가지 중에서 하나만 해결한다.</p><h3 id="2-회피avoidance">2. 회피(Avoidance)</h3><p>교착상태의 발생조건을 없애지 않고 교착상태가 발생하지 않도록 알고리즘을 적용한다. 대표적으로 자원 할당 그래프 알고리즘과 은행원 알고리즘이 있다.</p><h3 id="3-회복recovery">3. 회복(Recovery)</h3><p>교착상태가 발생하는 것을 막지 않고, 교착상태가 발생하면 발생 이후에 문제를 해결한다.</p><h3 id="4-무시ignore">4. 무시(Ignore)</h3><p>교착상태를 해결할 때 문맥교환(Context switching)에 의한 오버헤드로 성능 저하가 생기는데, 교착상태에 의한 성능저하보다 이를 해결하기 위한 성능 저하가 크면 무시한다.</p><h2 id="문제-설명">문제 설명</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/4.png" alt="4.png" /></p><p>출처: <a href="https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C">위키백과</a></p><p>철학자 N명이 식탁에 둘러 앉으며, 테이블 가운데에 놓인 밥을 먹는다.</p><p>철학자는 식사하고, 잠들었다가, 생각하는 것을 반복한다.</p><p>철학자는 식사하기 위해서 2개의 포크를 집어야 하며, 전체 포크의 개수는 N개로 철학자의 수와 동일하다.</p><p>식사하는 동안 포크는 계속 들고 있으며, 식사를 끝내면 포크를 내려놓고 잠들었다가 생각한다.</p><p>포크의 개수는 N개이기 때문에 양 옆에 있는 사람과 포크를 공유해야 한다.</p><p>다만, 한 번에 하나의 포크를 집을 수 있으며, 이미 옆사람이 포크를 잡고 있다면 식사가 끝나기를 기다렸다가 포크를 집는다.</p><h2 id="교착상태가-발생하는-이유">교착상태가 발생하는 이유</h2><p>5명의 철학자가 식사를 한다고 해보자. 그리고 모든 철학자가 왼쪽에 있는 포크를 집는다고 해보자.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/5.png" alt="5.png" /></p><p>그 다음 오른쪽 포크를 잡아야 하는데, 이미 다른 철학자가 잡고 있기 때문에 포크를 내려놓을 때까지 기다려야한다. 하지만 모든 철학자가 그런 상태에 놓여있어서 철학자들이 아무 것도 진행할 수 없게되는 교착상태(Deadlock)가 된다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/6.png" alt="6.png" /></p><h2 id="철학자들에게-밥-먹이는-방법">철학자들에게 밥 먹이는 방법</h2><p>철학자마다 순서대로 번호를 매긴다고 해보자.</p><p>이 상태에서 해결하는 방법은 아래와 같다.</p><ol><li>짝수 먼저 식사 시작하기 (홀수는 잠시 잠들었다가 시작)<li>짝수는 왼쪽에 있는 포크를 먼저 집고, 홀수는 오른쪽에 있는 포크를 먼저 집는다.</ol><p>이번 과제에서는 1번 방법으로 문제를 해결했으며, 교착상태 발생 조건 중에서 순환대기가 발생하지 않도록 구현했다.</p><h1 id="mandatory-1">Mandatory</h1><h2 id="구조-설계">구조 설계</h2><ol><li>인자를 파싱해서 저장한다.<li>유효한 인자인지 확인한다.<ol><li>유효하지 않으면 프로그램 종료</ol><li>철학자(스레드)를 생성한다.<ol><li>철학자는 식사 → 수면 → 생각을 반복한다.</ol><li>모니터링 스레드 생성<ol><li>철학자가 식사를 하지 못하거나, 모든 철학자가 식사를 마치면 메인 스레드에서 모든 자원을 회수하고 프로그램을 종료한다.</ol></ol><h2 id="1-인자-파싱">1. 인자 파싱</h2><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>./philo <span class="o">[</span>철학자의 수, 생존 시간, 식사 소요 시간, 수면 소요 시간, <span class="o">(</span>최소 식사 횟수<span class="o">)]</span>
</pre></table></code></div></div><p>모든 인자는 양의 정수 값을 가진 <code class="language-plaintext highlighter-rouge">int</code> 형 범위 내의 값만 받았다.</p><p>파싱을 할 때 숫자가 아닌 값이 들어오거나 음수가 들어오면 <code class="language-plaintext highlighter-rouge">-1</code> 로 저장해서 오류가 발생했다는 것을 명시했다.</p><h2 id="2-유효한-인자-확인">2. 유효한 인자 확인</h2><p>0 또는 음수가 들어오는 경우는 프로그램을 바로 종료한다.</p><p>특히, 0 이 들어오는 경우는 논리적으로 옳지 않다고 생각했다.</p><p>예를 들어, 생존 시간이 0 이라면 생존 자체가 불가능하고, 최소 식사 횟수가 0 이라면 철학자가 전혀 먹지 않아도 된다는 의미로 해석했다.</p><h2 id="3-철학자-생성">3. 철학자 생성</h2><p>반복문을 돌며 철학자의 수만큼 스레드를 생성한다.</p><h3 id="포크-할당">포크 할당</h3><p>철학자의 인덱스는 1부터 시작하고, 포크의 인덱스는 0부터 시작하도록 했다.</p><p>이처럼 철학자의 왼쪽 포크는 <code class="language-plaintext highlighter-rouge">i</code> 인덱스, 오른쪽 포크는 나머지 연산자를 사용해서 <code class="language-plaintext highlighter-rouge">(i + 1) % num_of_philo</code> 인덱스를 잡도록 했다.</p><p>즉, 1번 철학자의 왼쪽 포크는 0번 인덱스, 오른쪽 포크는 1번 인덱스를 가지며, 5번 철학자의 왼쪽 포크는 4번 인덱스, 오른쪽 포크는 0번 인덱스를 가진다.</p><div class="table-wrapper"><table><thead><tr><th>철학자 인덱스<th>1<th>2<th>3<th>4<th>5<tbody><tr><td>포크 인덱스<td>0<td>1<td>2<td>3<td>4</table></div><p>이를 코드로 표현하면 아래와 같다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#define LEFT  0
#define RIGHT 1
</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_of_philo</span><span class="p">)</span> <span class="c1">// 철학자의 수만큼 반복</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="c1">// 포크 할당</span>
	<span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forks</span><span class="p">[</span><span class="n">LEFT</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">forks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 왼쪽 포크</span>
	<span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">forks</span><span class="p">[</span><span class="n">RIGHT</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">forks</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_of_philo</span><span class="p">];</span> <span class="c1">// 오른쪽 포크</span>
	<span class="p">...</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="루틴-함수">루틴 함수</h3><p>철학자 스레드가 수행하는 함수는 아래와 같이 작성했다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span>	<span class="o">*</span><span class="nf">start_routine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">t_philo</span>	<span class="o">*</span><span class="n">philo</span><span class="p">;</span>

	<span class="n">philo</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_philo</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 짝수이면 잠시 잠들었다가 식사 시작 (= 홀수 먼저 식사)</span>
		<span class="n">usleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_other_philo_dead</span><span class="p">(</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
			<span class="k">break</span> <span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_all_philo_eaten</span><span class="p">(</span><span class="n">philo</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
			<span class="k">break</span> <span class="p">;</span>
		<span class="n">start_eating</span><span class="p">(</span><span class="n">philo</span><span class="p">);</span>
		<span class="n">start_sleeping</span><span class="p">(</span><span class="n">philo</span><span class="p">);</span>
		<span class="n">start_thinking</span><span class="p">(</span><span class="n">philo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>짝수 번째 철학자인 경우 잠시 <code class="language-plaintext highlighter-rouge">usleep</code> 에 들어갔다가 행동을 반복한다.</p><p>그리고 다른 철학자가 죽었거나 모든 철학자가 식사를 마쳤다면 행동을 멈춘다.</p><h2 id="4-모니터링-스레드-생성">4. 모니터링 스레드 생성</h2><p>메인 스레드에서 모든 철학자의 상태를 확인하는 스레드를 생성했다.</p><p>모니터링 스레드는 1번 철학자부터 N번 철학자까지 순서대로 확인하며, 현재 보고 있는 철학자가 죽었는지, 모든 철학자가 식사를 마쳤는지 확인한다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span>	<span class="o">*</span><span class="nf">start_monitoring</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">t_philo</span>	<span class="o">*</span><span class="n">philos</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">philos</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_philo</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_philo_dead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">change_common_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DIE</span><span class="p">);</span>
			<span class="n">print_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DIED</span><span class="p">);</span>
			<span class="k">break</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_all_philo_eaten</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">change_common_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">EATEN</span><span class="p">);</span>
			<span class="k">break</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">args</span><span class="p">.</span><span class="n">num_of_philo</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="구조도">구조도</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/7.png" alt="7.png" /></p><p>철학자의 생존 여부를 확인하는 1개의 스레드가 모든 철학자를 확인한다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/8.png" alt="8.png" /></p><p>모니터링 스레드는 철학자 한 명씩 순차적으로 생존 시간이 지났는지, 최소 식사 횟수를 채웠는지 확인한다.</p><p>생존 시간이 지났다면 철학자 스레드들과 공유하는 변수에 생존 여부를 <code class="language-plaintext highlighter-rouge">TRUE</code> 로 바꾸어준다. 마찬가지로 모든 철학자들이 최소 식사 횟수를 채웠으면 공유하는 변수에 식사 완료 여부를 <code class="language-plaintext highlighter-rouge">TRUE</code> 로 바꾼다.</p><p>각 철학자 스레드는 다른 철학자가 죽었는지 감지하기 위해 공통으로 사용하는 변수에 접근해서 데이터를 읽는다. 그리고 최소 식사 횟수를 채우면 공유하는 변수에 식사를 완료한 철학자의 수를 1씩 올린다. 철학자는 행동을 하기 전에 다른 철학자가 죽었는지 아니면 모든 철학자가 식사를 완료했는지 공통 변수에 접근해서 확인한다.</p><p>이때, 데이터 레이스가 발생하지 않도록 조심해야 한다. 두 개 이상의 스레드가 동시에 같은 변수에 접근하는데, 하나는 데이터를 읽으려고 하고, 다른 하나는 데이터를 수정하려고 한다면 두 데이터가 서로 다를 수도 있기 때문이다.</p><p>예를 들어, 2개의 스레드가 <code class="language-plaintext highlighter-rouge">a</code> 라는 <code class="language-plaintext highlighter-rouge">int</code> 형 변수에 접근하는데, 1번 스레드가 먼저 <code class="language-plaintext highlighter-rouge">a</code> 변수의 값이 2 이라는 것을 확인만 하고, 그 다음 2번 스레드는 변수 <code class="language-plaintext highlighter-rouge">a</code> 의 값에 +1 을 한다고 해보자. 그러면 1번 스레드는 <code class="language-plaintext highlighter-rouge">a</code> 를 2로 인식하고 있고, 2번 스레드는 <code class="language-plaintext highlighter-rouge">a</code> 를 3으로 인식하고 있는 것이다. 따라서 <code class="language-plaintext highlighter-rouge">a</code> 라는 동일한 변수에 대해 각 스레드가 다른 데이터를 가지고 있으므로 모든 스레드가 동일한 데이터를 가지고 있다고 말할 수 없다.</p><p>그렇기 때문에 모든 스레드가 같은 데이터를 갖기 위해서는 데이터에 대한 접근 및 수정 순서를 순차적으로 해주어야 한다. 데이터 레이스가 발생하지 않으려면 뮤텍스(mutex)를 적절하게 사용해야 하며, 변수의 값을 확인할 때, 변수의 값을 수정할 때 모두 뮤텍스로 변수를 감싸야 한다.</p><p>예를 들어, 모니터링 스레드가 수행하는 루틴 함수는 아래와 같이 작성할 수 있다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="c1">// 모니터링 스레드</span>

<span class="c1">// 공통으로 사용하는 변수의 값을 변경</span>
<span class="kt">void</span>	<span class="nf">change_common_data</span><span class="p">(</span><span class="n">t_philo</span> <span class="o">*</span><span class="n">philo</span><span class="p">,</span> <span class="k">enum</span> <span class="n">e_philo_status</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">DIE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dead_flag_lock</span><span class="p">);</span>
		<span class="n">philo</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">is_other_philo_dead</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">dead_flag_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">EATEN</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data_lock</span><span class="p">);</span>
		<span class="n">philo</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">is_all_philos_eaten</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 철학자가 생존했는지 확인</span>
<span class="kt">int</span> <span class="nf">is_philo_dead</span><span class="p">(</span><span class="n">t_philo</span> <span class="o">*</span><span class="n">philo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">time_lock</span><span class="p">);</span> <span class="c1">// 철학자의 식사 시간이 갱신되는 것도 동기화 필요</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">is_alive</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philo</span><span class="o">-&gt;</span><span class="n">time_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 모니터링 스레드의 루틴 함수</span>
<span class="kt">void</span>	<span class="o">*</span><span class="nf">start_monitoring</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="n">t_philo</span>	<span class="o">*</span><span class="n">philos</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">philos</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_philo</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_philo_dead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">change_common_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DIE</span><span class="p">);</span>
			<span class="n">print_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DIED</span><span class="p">);</span>
			<span class="k">break</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_all_philo_eaten</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">change_common_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">EATEN</span><span class="p">);</span>
			<span class="k">break</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">philos</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">args</span><span class="p">.</span><span class="n">num_of_philo</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="bonus-1">Bonus</h1><p>Mandatory 에서 데이터 레이스가 발생하지 않도록 뮤텍스(mutex) 를 사용했다면, Bonus 에서는 세마포어(semaphore)를 사용한다.</p><p>그리고 철학자를 스레드로 생성하는 것이 아닌 자식 프로세스로 생성(<code class="language-plaintext highlighter-rouge">fork()</code> 함수 이용)해야 한다.</p><h2 id="세마포어semaphore">세마포어(Semaphore)</h2><p>세마포어는 뮤텍스와 달리 0 이상 값을 가지며, P연산(<code class="language-plaintext highlighter-rouge">sem_wait</code>)과 V연산(<code class="language-plaintext highlighter-rouge">sem_post</code>)이 가능하다.</p><p>P연산은 <code class="language-plaintext highlighter-rouge">-1</code> 을, V연산은 <code class="language-plaintext highlighter-rouge">+1</code> 을 해주는 연산이라 생각하면 된다.</p><p>또한, 세마포어는 초기값을 설정할 수 있기 때문에 뮤텍스와 달리 원하는 횟수만큼 빼거나 더할 수 있다.</p><p>그렇기 때문에 Mandatory 에서는 철학자 사이에 포크가 1개씩 놓여있었다면, Bonus 는 모든 포크가 테이블의 한 가운데에 있다고 이해하면 된다.</p><p>세마포어의 현재 카운트가 0이면 <code class="language-plaintext highlighter-rouge">sem_wait</code> 는 대기하고 있다가 카운트가 1이 되는 순간 실행하는 특징을 갖고 있다. 이는 뮤텍스가 unlock 되면 lock 을 거는 것과 같다.</p><p>세마포어는 Linxu 에서는 <code class="language-plaintext highlighter-rouge">/dev/shm</code> 또는 <code class="language-plaintext highlighter-rouge">/dev/sem</code> 폴더에 저장되는 파일이다. 하지만 Mac OS 에는 해당 폴더가 존재하지 않아서 직접 확인할 수 없었다.</p><h2 id="구조도-1">구조도</h2><h3 id="1-철학자-모니터링-스레드">1. 철학자 모니터링 스레드</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/9.png" alt="9.png" /></p><p>스레드와 달리 프로세스는 변수 공유가 되지 않기 때문에 세마포어를 통해서 정보를 주고 받아야 한다.</p><p>그래서 프로그램이 종료되어야 하는지 확인하는 모니터링 스레드를 메인 프로세스에서 생성해주었다. 프로그램의 종료를 알리는 <code class="language-plaintext highlighter-rouge">finish_semaphore</code> 의 초기값을 0으로 설정하고, <code class="language-plaintext highlighter-rouge">sem_wait(finish_semaphore)</code> 를 수행하면 어디선가 <code class="language-plaintext highlighter-rouge">sem_post(finish_semaphore)</code> 를 수행하기 전까지 대기한다.</p><p>자식 프로세스마다 철학자의 죽음을 감지하는 모니터링 스레드를 하나씩 생성했다. 즉, 철학자가 N명이면 모니터링 스레드도 N개가 된다. 사실 스레드가 많아지기 때문에 자원을 효율적으로 사용하지는 못하긴 하지만, 작동에는 큰 문제가 없었다.</p><p>철학자가 죽으면 모니터링 스레드는 <code class="language-plaintext highlighter-rouge">sem_post(finish_semaphore)</code> 를 수행한다. 그리고 종료를 감지하는 스레드는 <code class="language-plaintext highlighter-rouge">sem_wait</code> 를 실행하면서 자식 프로세스들에게 <code class="language-plaintext highlighter-rouge">kill</code> 함수를 사용해서 시그널을 보낸다.</p><p>종료 감지 스레드를 코드로 표현하면 다음과 같다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// 종료 감지 스레드</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sem_wait</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">finish_sem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 모니터링 스레드에서 sem_post 수행 시 아래의 코드 실행</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="c1">// 자식 프로세스 종료</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">num_of_philo</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">child_process</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SIGKILL</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="2-식사-완료-감지-스레드">2. 식사 완료 감지 스레드</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/10.png" alt="10.png" /></p><p>철학자들이 최소 식사 횟수를 모두 채웠는지 감지하기 위해서 메인 프로세스에서 식사 완료 감지 스레드를 생성했다.</p><p>마찬가지로 세마포어의 초기값을 0으로 설정하고, 철학자의 수만큼 <code class="language-plaintext highlighter-rouge">sem_wait(eaten_semaphore)</code> 를 수행한다. 철학자의 수만큼 반복하는 이유는 철학자 스레드에서 최소 식사 횟수를 모두 채우면 <code class="language-plaintext highlighter-rouge">sem_post(eaten_semaphore)</code> 를 수행하기 때문이다.</p><p>철학자가 모두 식사를 마치면 <code class="language-plaintext highlighter-rouge">sem_post(finish_semaphore)</code> 를 수행해서 전체 프로세스가 종료되도록 알린다.</p><p>이를 코드로 표현하면 아래와 같다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 식사 완료 감지 스레드</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">num_of_philo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sem_wait</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">eaten_sem</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">sem_post</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">finish_sem</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="3-종료-감지-스레드">3. 종료 감지 스레드</h3><p>철학자 중 누군가 죽었거나, 식사를 마치면 모든 프로세스를 종료시키는 스레드이다.</p><p>최소 식사 횟수를 다 채우지 못하고 철학자가 죽었다면 식사 완료 감지 스레드는 계속 <code class="language-plaintext highlighter-rouge">sem_wait</code> 를 하는 상태라서 프로그램이 종료되지 않는다.</p><p>그래서 <code class="language-plaintext highlighter-rouge">sem_wait(finish_semaphore)</code> 가 실행되면 식사 완료 감지 스레드가 종료될 수 있도록 철학자의 수만큼 <code class="language-plaintext highlighter-rouge">sem_post(eaten_semaphore)</code> 를 수행하도록 했다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// 종료 감지 스레드</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sem_wait</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">finish_sem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 식사 완료 감지 스레드 종료</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">num_of_philo</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">sem_post</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">eaten_sem</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// 자식 프로세스 종료</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">num_of_philo</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">kill</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">child_process</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SIGKILL</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="테스터">테스터</h1><ul><li>https://github.com/newlinuxbot/Philosphers-42Project-Tester<ul><li>보너스는 테스터기에서 사용하는 인자값대로 실행하는 것을 추천한다.</ul><li><a href="https://nafuka11.github.io/philosophers-visualizer/">philosophers-visualizer</a><ul><li>시간의 흐름에 따라 철학자들이 식사, 수면, 생각하는 것을 시각화 해주는 사이트이다.</ul></ul><h1 id="회고">회고</h1><h2 id="페어-프로그래밍에-코드-리뷰-곁들이기">페어 프로그래밍에 코드 리뷰 곁들이기</h2><p>이번 철학자 과제도 지난 과제들과 마찬가지로 2명이 팀을 이루어 프로그램을 완성하는 페어 프로그래밍을 활용해서 과제를 진행했다.</p><p>다만, 이번에는 다른 분들과 함께 총 5명이 모여 코드 리뷰 스터디를 이루어 진행했다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/11.png" alt="11.png" /></p><p>Slack 에서 발견한 스터디 모집 게시물</p><p>평일 오후 1시에 모여서 각자 작성한 코드를 공유하고, 궁금하거나 이해되지 않는 부분을 서로에게 물어보고 답변하는 방식으로 진행했다.</p><p>github 에 함께 공유할 repository 를 생성했고, submodule 로 각자의 repository 를 공유하도록 했다. git submodule 을 이번에 처음 써보았는데, 여러 명이 각자의 작업 내역을 공유하기 좋은 기능이라는 것을 알게 되어 이를 글로 작성하여 스터디원들 뿐만 아니라 다른 분들도 참고할 수 있게 글로 정리하였다. 이 과정에서 git 에 조금 더 익숙해질 수 있었다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/12.png" alt="12.png" /></p><p><a href="https://80000coding.oopy.io/7dcf9326-607b-4ef3-8bc7-6803fef7fc11">git submodule 사용해서 스터디에 활용하기</a> [팔만코딩경]</p><h2 id="우리는-코드-공동체입니다">우리는 코드 공동체입니다.</h2><p>스터디 초반에는 처음 보는 개념과 함수들을 공부해야 하기 때문에 코드 리뷰를 받을 수 있는 부분이 없었다. 대신 과제를 어떤 방식으로 접근할 것인지, 과제에서 요구하는 것이 무엇인지 파악하기 위해 많은 이야기를 나누었다. 그리고 이전에 철학자 과제를 평가해본 적이 없어서 이미 과제를 해결하신 분들에게 어떻게 과제를 해결하면 좋을지 지식 품앗이를 요청하거나, 개인적으로 여쭤보기도 했다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/13.png" alt="13.png" /></p><p>jujeon 님께서 진행하신 지식 품앗이 참여 후기</p><p>만약 처음부터 서브젝트만을 통해 문제를 해결했다면 많이 막막했을 것 같은데, 다른 분들의 도움을 받아서 수월하게 진행할 수 있었다. 그리고 가장 좋은 학습은 다른 분들 평가를 많이 다니면서 과제에 대한 이해도를 높이고, 다양한 관점에서 작성된 코드들을 많이 접해보는 것이라는 것을 느꼈다. 철학자 과제를 하면서 평가를 많이 다녔는데, 한번도 철학자 평가가 안 잡히다가 철학자 과제를 통과하고 나서야 잡혔던 것이 아쉬웠다.</p><p>스터디 중반에 접어 들면서 본격적인 코드 리뷰가 가능해졌다. 다른 동료 분들의 코드를 보며 코드에 녹아내려진 생각의 흐름과 논리를 이해했다. 그리고 이해되지 않는 부분은 바로 질문해서 해소하거나, 좋은 의견을 제시함으로써 서로의 코드 퀄리티를 높여갔다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/14.png" alt="14.png" /></p><p>슬랙에서 주고 받은 정보들</p><p>스터디를 좋았던 점을 꼽으라면 하면서 각자 새롭게 알게 된 사실이나, 다른 동료 분들과 이야기하며 얻은 정보를 서로 공유를 했다는 것이다. 매일 만나서 서로 정보와 의견을 나누었기 때문에 점진적으로 과제에 대한 이해도를 높일 수 있었다.</p><h2 id="그럼에도-코드-리뷰는-계속-되어야-한다">그럼에도 코드 리뷰는 계속 되어야 한다.</h2><p>사실 매일 만나서 코드 리뷰를 받는 건 어려운 일이다.</p><p>어떤 날은 문제점을 해결하지 못해서 코드 1줄조차 수정하지 못해 코드 리뷰를 받을 수 없었던 적도 있었다. 그래서 스터디원들이 아닌 다른 분들에게 발생한 문제에 대해 여쭤보기도하고, 코드를 진찰(?)해달라고 부탁했다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/15.png" alt="15.png" /></p><p>코드에 마가 꼈습니다.</p><p>하지만 무엇이 문제인지, 어디서 발생하는 문제인지 감조차 잡지 못해서 코드에 마가 꼈다고 결론을 내리고 코드를 전부 날리고 다시 작성하기도 했다.</p><p>신기한 건 이해한 내용을 바탕으로 다시 처음부터 코드를 작성하면 생각보다 잘 작동한다는 것이었다. 불필요한 변수와 함수를 걷어내고, 생각의 흐름을 정리하다보니 코드를 자연스럽게 작성할 수 있었다. 글을 작성할 때도 생각이 정리되면 알아서 술술 써내려가지는 것처럼 코드도 마찬가지로 개념에 대한 이해가 정립되면 물 흐르듯 쓸 수 있었다.</p><p>코드 리뷰를 받을 때는 다른 스터디원 분들의 질문의 본질적인 의도를 파악하기 위해 노력했고, 혹시라도 놓치고 있는 개념이 있는지 파악하고자 했다. 반대로 코드 리뷰를 할 때는 상대방의 코드에서 배울 점이 무엇인지, 개선되면 좋을 것 같은 부분이 있는지, 나의 코드와 비교했을 때 어떤 점이 다르고 어떤 점이 비슷한지 비교하며 자연스럽게 코드를 작성하는 관점을 넓힐 수 있었다.</p><h2 id="번뜩이는-아이디어는-가끔-나를-찾아온다">번뜩이는 아이디어는 가끔 나를 찾아온다.</h2><blockquote><p>⚠️ 주의 : 과제에 대한 스포일러가 포함되어 있습니다.</p></blockquote><p>철학자 보너스 과제에서는 뮤텍스가 아닌 세마포어를 사용해서 프로세스 간 통신을 구현해야 한다.</p><p>메인 프로세스에서 <strong>프로그램의 종료를 감지하는 스레드</strong>와 <strong>모든 철학자가 식사를 완료했는지 감지하는 스레드</strong>로 총 2개의 모니터링을 구현했다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/images/2022/2022-10-13-42seoul-philosopher-implementation-retrospective/16.png" alt="16.png" /></p><p>하지만 철학자가 식사를 하다가 생존 시간이 지나버린 경우에는 <strong>모든 철학자가 식사를 완료했는지 감지하는 스레드</strong>가 종료되지 않고 계속 대기하는 현상이 발생했다.</p><p>이 문제를 해결하기 위해서 <strong>프로그램의 종료를 감지하는 스레드</strong>가 프로그램을 종료하기 전에 <strong>모든 철학자가 식사를 완료했는지 감지하는 스레드</strong>가 종료될 수 있도록 처리를 했다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// 프로그램의 종료를 감지하는 스레드</span>

<span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="err">식사</span> <span class="err">종료</span> <span class="err">감지</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 모든 철학자가 식사를 완료했는지 감지하는 스레드가 종료되도록 처리</span>
	<span class="k">while</span> <span class="p">(</span><span class="err">식사</span> <span class="err">횟수</span> <span class="err">감지</span> <span class="err">스레드가</span> <span class="err">종료할</span> <span class="err">때</span> <span class="err">까지</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="err">식사</span> <span class="err">횟수</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이 문제만 해결하면 과제를 마무리할 수 있었는데, 찰나의 순간에 이런 아이디어를 떠올렸다는 사실에 스스로 놀랐었다.</p><p>모든 과제를 이렇게 해결했다면 정말 좋았겠지만, 매번 그렇지는 않아서 이번에 맞이한 행운을 두고두고 기억하고 싶어 함께 적었다.</p><h2 id="되돌아보며">되돌아보며</h2><p>이번 과제를 하며 아쉬웠던 점은 처음부터 너무 완벽한 코드를 짜려고 하다보니 코드가 잘 나오지 않았다는 것이다. 그리고 디버깅을 하려고 해도 어디서 문제가 발생했는지 쉽게 파악할 수 없었다.</p><p>그래서 일단 작동하는 코드를 최대한 작게 만들어서 테스트를 거치고, 조금씩 덧붙여가면서 완성도를 높이는 것이 훨씬 빠르고 효과적이라는 것을 많이 느꼈다.</p><p>그리고 코드 리뷰는 많이 받아볼수록 좋다는 것을 느꼈다. 평가를 받을 때만 코드를 설명하는 것이 아닌 리뷰 시간마다 코드를 설명해야 하기 때문에 실시간 디펜스를 해야 한다. 이 과정에서 평가를 자연스럽게 준비할 수 있게 되고, 발생할 수 있는 예외 상황에 대해서도 충분히 많이 생각해볼 수 있어서 좋았다. 그리고 상대방의 질문을 정확하게 이해하는 것도 결코 쉽지 않기 때문에 코드 리뷰 스터디를 통해 상대방의 말을 이해하는 연습을 충분히 할 수 있었다.</p><p>과제를 시작해서 마치기까지 1달이라는 시간이 걸렸지만, 이 과정에서 충분히 많은 것을 공부하고 얻어갈 수 있었다. 누군가 이 과제를 하게 된다면 기꺼이 배운 내용을 공유하고 싶다. 다른 분들이 우리에게 기꺼이 시간을 내어 도와주었던 것처럼.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/42seoul/'>42seoul</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고 - Dev Joon&url=https://han-joon-hyeok.github.io/posts/42seoul-philosopher-implementation-retrospective/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고 - Dev Joon&u=https://han-joon-hyeok.github.io/posts/42seoul-philosopher-implementation-retrospective/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[42Seoul] 식사하는 철학자(Philosopher) 과제 구현 과정 및 회고 - Dev Joon&url=https://han-joon-hyeok.github.io/posts/42seoul-philosopher-implementation-retrospective/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/c-bitwise-operation-between-different-integer-sizes/">[C언어] 자료형 크기 차이로 인한 비트 연산 오류 해결 방법</a><li><a href="/posts/connect-to-ec2-without-ssh-key-using-session-manager/">[AWS] EC2 인스턴스 ssh 키 없이 터미널 접속하는 방법 (AWS Session Manager)</a><li><a href="/posts/how-to-access-geo-restricted-websites-using-mullvad-vpn/">국가 제한이 걸린 사이트에 접속하는 방법 (feat. Mullvad VPN)</a><li><a href="/posts/network-overview/">네트워크 LAN, WAN / 스위치, 라우터 / IP 주소 / 서브넷 개념 정리</a><li><a href="/posts/what-is-nat/">NAT란?</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/born2beroot-install-virtual-machine/"><div class="card-body"> <span class="timeago small" > Aug 17, 2022 <i class="unloaded">2022-08-17T17:20:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Born2beroot] 1. 가상 머신 및 데비안 설치</h3><div class="text-muted small"><p> 과제 소개 Born2beroot 과제는 가상 머신에 운영체제를 설치하고, 여러 사용자가 운영체제를 이용할 수 있도록 기본 환경 설정을 하는 것이 목표이다. 파티션 설정, 비밀번호 정책, 방화벽 설정, SSH 연결, 운영체제 등을 배우게 된다. 추가로 보너스 과제를 수행한다면 워드 프레스를 설치하기 위해 웹 서버, WAS, DB 까지 가볍게 짚어볼 수...</p></div></div></a></div><div class="card"> <a href="/posts/born2beroot-install-sudo/"><div class="card-body"> <span class="timeago small" > Sep 3, 2022 <i class="unloaded">2022-09-03T23:20:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Born2beroot] 2. sudo 설치</h3><div class="text-muted small"><p> sudo 설치 CentOS 는 sudo 가 기본적으로 내장되어 있지만, 데비안은 그렇지 않기 때문에 sudo 를 별도로 설치해야 한다. sudo 란? 출처: xkcd 리눅스 운영체제에서 최고 관리자 권한으로 실행하는 프로그램이다. sudo 는 super user do(최고 권한 실행) 또는 substitute user do(다른 사용자의 ...</p></div></div></a></div><div class="card"> <a href="/posts/born2beroot-install-apparmor/"><div class="card-body"> <span class="timeago small" > Sep 4, 2022 <i class="unloaded">2022-09-04T22:20:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Born2beroot] 3. AppArmor 설치</h3><div class="text-muted small"><p> AppArmor 설치 AppArmor 는 데비안 운영체제 설치와 함께 설치된다. 해당 패키지가 설치되었는지 확인하기 위해서는 다음의 명령어를 사용한다. sudo dpkg -l apparmor sudo dpkg -l apparmor-utils 만약 설치되지 않았다면 다음과 같이 Version 와 Architecture 항목이 &lt;none&g...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/push-swap/" class="btn btn-outline-primary" prompt="Older"><p>[42Seoul] push_swap 구현 과정</p></a> <a href="/posts/what-is-thread/" class="btn btn-outline-primary" prompt="Newer"><p>스레드란?</p></a></div><script src="https://utteranc.es/client.js" repo="Han-Joon-Hyeok/Han-Joon-Hyeok.github.io" issue-term="pathname" label="Comments" theme="preferred-color-scheme" crossorigin="anonymous" async> </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/han-joon-hyeok">Joon Hyeok Han</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/programmers/">programmers</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/level2/">level2</a> <a class="post-tag" href="/tags/level1/">level1</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/pipex/">pipex</a> <a class="post-tag" href="/tags/born2beroot/">born2beroot</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://han-joon-hyeok.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
